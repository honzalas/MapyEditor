<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapyEditor - Editor tras</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #1a1a1a;
        }

        #app {
            display: flex;
            height: 100vh;
        }

        #map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        #map.create-mode {
            cursor: crosshair !important;
        }

        #map.create-mode * {
            cursor: crosshair !important;
        }

        #map.ctrl-mode {
            cursor: crosshair !important;
        }

        #map.ctrl-mode * {
            cursor: crosshair !important;
        }

        #status-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 8px 16px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 14px;
            font-weight: 500;
        }

        #right-panel {
            width: 400px;
            background: #2d2d2d;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #1a1a1a;
        }

        .panel-section {
            background: #3a3a3a;
            padding: 16px;
            margin-bottom: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .panel-section h3 {
            margin-bottom: 12px;
            font-size: 16px;
            color: #e0e0e0;
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            justify-content: space-between;
        }

        .panel-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-header-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #2196F3, #4CAF50);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .panel-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #e0e0e0;
        }

        .about-link {
            color: #2196F3;
            text-decoration: none;
            font-size: 13px;
            transition: color 0.2s;
            white-space: nowrap;
        }

        .about-link:hover {
            color: #4CAF50;
        }

        .info-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-label {
            font-weight: 500;
            color: #b0b0b0;
        }

        .info-value {
            color: #e0e0e0;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button.primary {
            background: #2196F3;
            color: white;
        }

        button.primary:hover {
            background: #1976D2;
        }

        button.success {
            background: #4CAF50;
            color: white;
        }

        button.success:hover {
            background: #388E3C;
        }

        button.secondary {
            background: #757575;
            color: white;
        }

        button.secondary:hover {
            background: #616161;
        }

        button.warning {
            background: #F57C00;
            color: white;
        }

        button.warning:hover {
            background: #E65100;
        }

        button.muted {
            background: #616161;
            color: #e0e0e0;
        }

        button.muted:hover {
            background: #757575;
        }

        .button-row {
            display: flex;
            gap: 8px;
        }

        .button-row button {
            margin-bottom: 0;
        }

        .button-row .btn-main {
            flex: 2;
        }

        .button-row .btn-secondary {
            flex: 1;
        }

        .button-compact {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .button-compact button {
            flex: 1;
            margin-bottom: 0;
            font-size: 13px;
            padding: 8px;
        }

        .button-compact button svg {
            vertical-align: middle;
            margin-right: 4px;
        }

        button:disabled {
            background: #e0e0e0 !important;
            color: #9e9e9e !important;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
            font-weight: 500;
            color: #e0e0e0;
        }

        .form-group input[type="text"],
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
            background: #2d2d2d;
            color: #e0e0e0;
        }

        .form-group input[type="text"]:focus,
        .form-group select:focus {
            outline: none;
            border-color: #2196F3;
        }

        input[type="file"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 14px;
            background: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
        }

        .dropzone {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #2d2d2d;
            margin-bottom: 12px;
            display: none;
        }

        .dropzone.visible {
            display: block;
        }

        .dropzone:hover {
            border-color: #2196F3;
            background: #353535;
        }

        .dropzone.dragover {
            border-color: #4CAF50;
            background: #2d4030;
            transform: scale(1.02);
        }

        .dropzone-content {
            pointer-events: none;
        }

        .dropzone svg {
            color: #b0b0b0;
            margin-bottom: 12px;
        }

        .dropzone-text {
            color: #e0e0e0;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .dropzone-hint {
            color: #888;
            font-size: 12px;
            margin: 0;
        }

        .leaflet-marker-icon.vertex-marker {
            cursor: pointer !important;
        }

        .leaflet-marker-icon.midpoint-marker {
            cursor: copy !important;
        }

        .dropzone-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .dropzone-loading p {
            color: #e0e0e0;
            margin-top: 12px;
            font-size: 14px;
        }

        .spinner {
            border: 3px solid #555;
            border-top: 3px solid #2196F3;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 16px 24px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
        }

        .route-tooltip {
            background: rgba(0, 0, 0, 0.85) !important;
            border: 1px solid #444 !important;
            color: #e0e0e0 !important;
            font-size: 13px !important;
            padding: 6px 10px !important;
            border-radius: 4px !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
        }

        .route-tooltip::before {
            border-top-color: rgba(0, 0, 0, 0.85) !important;
        }

        @media (max-width: 768px) {
            #app {
                flex-direction: column;
            }

            #map-container {
                height: 60vh;
            }

            #right-panel {
                width: 100%;
                height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="map-container">
            <div id="status-bar">Nevybran√° trasa</div>
            <div id="map"></div>
            <div id="loading-indicator">Pl√°nuji trasu...</div>
        </div>
        <div id="right-panel">
            <div class="panel-section">
                <div class="panel-header">
                    <div class="panel-header-left">
                        <div class="panel-header-icon">üó∫Ô∏è</div>
                        <h3>MapyEditor</h3>
                    </div>
                    <a href="About.html" class="about-link" target="_blank">‚ÑπÔ∏è O programu</a>
                </div>
                <div class="info-line">
                    <span class="info-label">Poƒçet tras:</span>
                    <span class="info-value" id="route-count">0</span>
                </div>
                <div class="info-line">
                    <span class="info-label">Aktivn√≠ trasa:</span>
                    <span class="info-value" id="active-route">-</span>
                </div>
                <div class="button-compact" style="margin-top: 12px;">
                    <button class="secondary" id="btn-import-gpx">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        Nahr√°t
                    </button>
                    <button class="secondary" id="btn-export-gpx">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                        Ulo≈æit
                    </button>
                </div>
            </div>

            <div class="panel-section" id="import-panel" style="display: none;">
                <h3>Import GPX</h3>
                <div id="dropzone" class="dropzone">
                    <div class="dropzone-content">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        <p class="dropzone-text">P≈ôet√°hnƒõte GPX soubory nebo kliknƒõte pro v√Ωbƒõr</p>
                        <p class="dropzone-hint">Podporuje v√≠ce soubor≈Ø najednou</p>
                    </div>
                    <div id="dropzone-loading" class="dropzone-loading" style="display: none;">
                        <div class="spinner"></div>
                        <p>Naƒç√≠t√°m trasy...</p>
                    </div>
                    <input type="file" id="gpx-input" accept=".gpx" multiple style="display: none;">
                </div>
                <button class="secondary" id="btn-close-import" style="width: 100%;">Zav≈ô√≠t</button>
            </div>

            <div class="panel-section">
                <h3>Vytvo≈ôen√≠ trasy</h3>
                <div class="button-compact">
                    <button class="primary" id="btn-create-routing">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polyline points="12 6 12 12 16 14"></polyline>
                        </svg>
                        Pl√°novan√°
                    </button>
                    <button class="primary" id="btn-create-manual">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                        Ruƒçn√≠
                    </button>
                </div>
            </div>

            <div class="panel-section" id="attributes-panel" style="display: none;">
                <h3>Atributy trasy</h3>
                <div class="form-group">
                    <label for="route-name">N√°zev</label>
                    <input type="text" id="route-name" placeholder="N√°zev trasy">
                </div>
                <div class="form-group">
                    <label for="route-color">Barva</label>
                    <select id="route-color">
                        <option value="red">ƒåerven√°</option>
                        <option value="blue">Modr√°</option>
                        <option value="green">Zelen√°</option>
                    </select>
                </div>
                <div class="button-row">
                    <button class="success btn-main" id="btn-save-route" disabled>Ulo≈æit trasu</button>
                    <button class="muted btn-secondary" id="btn-cancel-route" disabled>Storno</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================
        // CONFIGURATION
        // ======================
        const API_KEY = 'eyJpIjo1LCJjIjoxNjM3MjMxMTY1fQ.wQ9-T6PhNT85YhqKRZPbp-iAIosTyIDfdw_ADBdUrn0';
        const ROUTE_TYPE = 'foot_fast';

        // ======================
        // DATA MODEL
        // ======================
        let routes = [];
        let nextRouteId = 1;
        let activeRouteId = null;
        let mode = 'none'; // 'none', 'editing-manual', 'editing-routing'
        let tempRouteData = null; // Temporary data for route being created
        let routeBackup = null; // Backup of route before editing (for cancel)
        let ctrlPressed = false; // Track CTRL key state

        const colorMap = {
            red: '#D32F2F',
            blue: '#1976D2',
            green: '#388E3C'
        };

        // ======================
        // MAP INITIALIZATION
        // ======================
        const map = L.map('map').setView([49.8729317, 14.8981184], 8);

        /*
        We store all our tile layers in an object, because we will
        need to pass that to the layers switching map control.
        */
        const tileLayers = {
            'Z√°kladn√≠': L.tileLayer(`https://api.mapy.com/v1/maptiles/basic/256/{z}/{x}/{y}?apikey=${API_KEY}`, {
                minZoom: 0,
                maxZoom: 20,
                attribution: '<a href="https://api.mapy.com/copyright" target="_blank">&copy; Seznam.cz a.s. a dal≈°√≠</a>',
            }),
            'Turistick√°': L.tileLayer(`https://api.mapy.com/v1/maptiles/outdoor/256/{z}/{x}/{y}?apikey=${API_KEY}`, {
                minZoom: 0,
                maxZoom: 20,
                attribution: '<a href="https://api.mapy.com/copyright" target="_blank">&copy; Seznam.cz a.s. a dal≈°√≠</a>',
            }),
            'Zimn√≠': L.tileLayer(`https://api.mapy.com/v1/maptiles/winter/256/{z}/{x}/{y}?apikey=${API_KEY}`, {
                minZoom: 0,
                maxZoom: 20,
                attribution: '<a href="https://api.mapy.com/copyright" target="_blank">&copy; Seznam.cz a.s. a dal≈°√≠</a>',
            }),
            'Leteck√°': L.tileLayer(`https://api.mapy.com/v1/maptiles/aerial/256/{z}/{x}/{y}?apikey=${API_KEY}`, {
                minZoom: 0,
                maxZoom: 20,
                attribution: '<a href="https://api.mapy.com/copyright" target="_blank">&copy; Seznam.cz a.s. a dal≈°√≠</a>',
            }),
        };

        // Add the default Basic layer to the map (desaturated)
        tileLayers['Z√°kladn√≠'].addTo(map);

        // Leaflet has a built-in map control for switching layers
        L.control.layers(tileLayers).addTo(map);

        // Apply grayscale filter to Basic map layer
        // For initial load, apply after a short delay to ensure container is ready
        setTimeout(() => {
            const container = tileLayers['Z√°kladn√≠'].getContainer();
            if (container) {
                container.style.filter = 'grayscale(90%) opacity(60%)';
            }
        }, 100);

        // Also apply filter when switching to Basic map
        map.on('baselayerchange', function(e) {
            if (e.name === 'Z√°kladn√≠') {
                setTimeout(() => {
                    const container = tileLayers['Z√°kladn√≠'].getContainer();
                    if (container) {
                        container.style.filter = 'grayscale(90%) opacity(60%)';
                    }
                }, 50);
            }
        });

        // Add logo control
        const LogoControl = L.Control.extend({
            options: { position: 'bottomleft' },
            onAdd: function (map) {
                const container = L.DomUtil.create('div');
                const link = L.DomUtil.create('a', '', container);
                link.setAttribute('href', 'http://mapy.com/');
                link.setAttribute('target', '_blank');
                link.innerHTML = '<img src="https://api.mapy.com/img/api/logo.svg" />';
                L.DomEvent.disableClickPropagation(link);
                return container;
            },
        });
        new LogoControl().addTo(map);

        // ======================
        // LAYERS & MARKERS
        // ======================
        const routeLayers = {}; // routeId -> { line, markers }

        // ======================
        // UI ELEMENTS
        // ======================
        const statusBar = document.getElementById('status-bar');
        const loadingIndicator = document.getElementById('loading-indicator');
        const routeCountEl = document.getElementById('route-count');
        const activeRouteEl = document.getElementById('active-route');
        const attributesPanel = document.getElementById('attributes-panel');
        const routeNameInput = document.getElementById('route-name');
        const routeColorSelect = document.getElementById('route-color');

        // ======================
        // HELPER FUNCTIONS
        // ======================
        function updateUI() {
            routeCountEl.textContent = routes.length;
            
            const isEditing = mode !== 'none';
            const route = activeRouteId ? routes.find(r => r.id === activeRouteId) : null;
            const needsCrosshair = isEditing && route && (
                (route.routeMode === 'manual' && route.coordinates.length < 2) ||
                (route.routeMode === 'routing' && route.coordinates.length < 2)
            );
            
            // Update map cursor
            const mapElement = document.getElementById('map');
            if (needsCrosshair || (isEditing && ctrlPressed)) {
                mapElement.classList.add('create-mode');
            } else {
                mapElement.classList.remove('create-mode');
            }
            
            // Disable/enable buttons based on mode
            document.getElementById('btn-create-manual').disabled = isEditing;
            document.getElementById('btn-create-routing').disabled = isEditing;
            document.getElementById('btn-export-gpx').disabled = isEditing;
            document.getElementById('btn-import-gpx').disabled = isEditing;
            
            if (activeRouteId) {
                const route = routes.find(r => r.id === activeRouteId);
                activeRouteEl.textContent = route ? `${route.name || 'Bez n√°zvu'} (ID: ${route.id})` : '-';
                
                // Update status bar
                if (mode === 'editing-manual') {
                    if (route.coordinates.length < 2) {
                        statusBar.textContent = `Vytv√°≈ôen√≠ ruƒçn√≠ trasy: ${route.name || 'Bez n√°zvu'} - klikejte do mapy`;
                    } else {
                        statusBar.textContent = `√öprava ruƒçn√≠ trasy: ${route.name || 'Bez n√°zvu'}`;
                    }
                } else if (mode === 'editing-routing') {
                    if (route.coordinates.length === 0) {
                        statusBar.textContent = `Vytv√°≈ôen√≠ pl√°novan√© trasy: ${route.name || 'Bez n√°zvu'} - nastavte start`;
                    } else if (route.coordinates.length === 1) {
                        statusBar.textContent = `Vytv√°≈ôen√≠ pl√°novan√© trasy: ${route.name || 'Bez n√°zvu'} - nastavte c√≠l`;
                    } else {
                        statusBar.textContent = `√öprava pl√°novan√© trasy: ${route.name || 'Bez n√°zvu'}`;
                    }
                }
                
                // Show attributes panel
                attributesPanel.style.display = 'block';
                routeNameInput.value = route ? route.name : '';
                routeColorSelect.value = route ? route.color : 'red';
                
                // Enable save and cancel buttons
                document.getElementById('btn-save-route').disabled = false;
                document.getElementById('btn-cancel-route').disabled = false;
            } else {
                activeRouteEl.textContent = '-';
                statusBar.textContent = 'Nevybran√° trasa';
                attributesPanel.style.display = 'none';
                document.getElementById('btn-save-route').disabled = true;
                document.getElementById('btn-cancel-route').disabled = true;
            }
        }

        function showLoading() {
            loadingIndicator.style.display = 'block';
        }

        function hideLoading() {
            loadingIndicator.style.display = 'none';
        }

        function getColorHex(colorName) {
            return colorMap[colorName] || colorMap.red;
        }

        // ======================
        // ROUTE RENDERING
        // ======================
        function renderRoute(route, isActive = false) {
            // Remove existing layer
            if (routeLayers[route.id]) {
                if (routeLayers[route.id].line) {
                    map.removeLayer(routeLayers[route.id].line);
                }
                if (routeLayers[route.id].markers) {
                    routeLayers[route.id].markers.forEach(m => map.removeLayer(m));
                }
            }

            // Clean up temporary markers for creating-routing mode
            if ((mode === 'creating-routing' || mode === 'editing-routing') && tempRouteData) {
                if (tempRouteData.startMarker) {
                    map.removeLayer(tempRouteData.startMarker);
                    tempRouteData.startMarker = null;
                }
                if (tempRouteData.endMarker) {
                    map.removeLayer(tempRouteData.endMarker);
                    tempRouteData.endMarker = null;
                }
                if (tempRouteData.waypointMarkers) {
                    tempRouteData.waypointMarkers.forEach(m => map.removeLayer(m));
                    tempRouteData.waypointMarkers = [];
                }
            }

            if (route.coordinates.length === 0) return;

            const color = getColorHex(route.color);
            const latLngs = route.coordinates.map(c => [c.lat, c.lon]);

            // Create polyline
            const line = L.polyline(latLngs, {
                color: color,
                weight: isActive ? 7 : 5,
                opacity: 0.95
            }).addTo(map);

            // Add tooltip for inactive routes
            if (!isActive) {
                line.bindTooltip(route.name || `Trasa ${route.id}`, {
                    permanent: false,
                    direction: 'top',
                    className: 'route-tooltip'
                });
            }

            // Click on line to activate (only if not currently editing)
            line.on('click', () => {
                if (mode === 'none') {
                    activateRoute(route.id);
                }
            });

            const markers = [];

            if (isActive) {
                // For routing mode (both creating and editing), show start, end, and waypoint markers
                if ((mode === 'creating-routing' || mode === 'editing-routing') && route.coordinates.length > 0) {
                    const firstCoord = route.coordinates[0];
                    const lastCoord = route.coordinates[route.coordinates.length - 1];
                    
                    // Start marker (green)
                    const startMarker = L.marker([firstCoord.lat, firstCoord.lon], {
                        draggable: true,
                        icon: L.divIcon({
                            className: 'vertex-marker',
                            html: '<div style="width: 16px; height: 16px; background: #4CAF50; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                            iconSize: [16, 16]
                        })
                    }).addTo(map);

                    startMarker.on('dragend', async () => {
                        const latlng = startMarker.getLatLng();
                        if (!tempRouteData) {
                            tempRouteData = {
                                start: { lat: latlng.lat, lon: latlng.lng },
                                end: { lat: lastCoord.lat, lon: lastCoord.lon },
                                waypoints: route.waypoints || [],
                                startMarker: startMarker,
                                endMarker: null
                            };
                        } else {
                            tempRouteData.start = { lat: latlng.lat, lon: latlng.lng };
                            tempRouteData.startMarker = startMarker;
                        }
                        await recalculateRoutingRoute();
                    });

                    // End marker (red)
                    const endMarker = L.marker([lastCoord.lat, lastCoord.lon], {
                        draggable: true,
                        icon: L.divIcon({
                            className: 'vertex-marker',
                            html: '<div style="width: 16px; height: 16px; background: #F44336; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                            iconSize: [16, 16]
                        })
                    }).addTo(map);

                    endMarker.on('dragend', async () => {
                        const latlng = endMarker.getLatLng();
                        if (!tempRouteData) {
                            tempRouteData = {
                                start: { lat: firstCoord.lat, lon: firstCoord.lon },
                                end: { lat: latlng.lat, lon: latlng.lng },
                                waypoints: route.waypoints || [],
                                startMarker: null,
                                endMarker: endMarker
                            };
                        } else {
                            tempRouteData.end = { lat: latlng.lat, lon: latlng.lng };
                            tempRouteData.endMarker = endMarker;
                        }
                        await recalculateRoutingRoute();
                    });

                    markers.push(startMarker, endMarker);
                    
                    // Store markers in tempRouteData
                    if (tempRouteData) {
                        tempRouteData.startMarker = startMarker;
                        tempRouteData.endMarker = endMarker;
                    }

                    // Waypoint markers (yellow)
                    const waypoints = route.waypoints || [];
                    waypoints.forEach((wp, index) => {
                        const wpMarker = L.marker([wp.lat, wp.lon], {
                            draggable: true,
                            icon: L.divIcon({
                                className: 'vertex-marker',
                                html: '<div style="width: 14px; height: 14px; background: #FFC107; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [14, 14]
                            })
                        }).addTo(map);

                        wpMarker.on('dragend', async () => {
                            const latlng = wpMarker.getLatLng();
                            if (!tempRouteData) {
                                tempRouteData = {
                                    start: { lat: firstCoord.lat, lon: firstCoord.lon },
                                    end: { lat: lastCoord.lat, lon: lastCoord.lon },
                                    waypoints: waypoints.map(w => ({ ...w }))
                                };
                            }
                            tempRouteData.waypoints[index] = { lat: latlng.lat, lon: latlng.lng };
                            await recalculateRoutingRoute();
                        });

                        markers.push(wpMarker);
                    });

                    // Add midpoint markers for creating new waypoints
                    // Use actual geometry points instead of geometric midpoints
                    // Divide route into segments based on waypoints
                    const allPoints = [firstCoord, ...waypoints, lastCoord];
                    
                    // For each segment, find the middle point from actual route geometry
                    for (let i = 0; i < allPoints.length - 1; i++) {
                        const segmentStart = allPoints[i];
                        const segmentEnd = allPoints[i + 1];
                        
                        // Find indices in coordinates array that are closest to segment start and end
                        let startIdx = 0;
                        let endIdx = route.coordinates.length - 1;
                        
                        if (i === 0) {
                            startIdx = 0;
                        } else {
                            // Find closest point to this waypoint
                            let minDist = Infinity;
                            for (let j = 0; j < route.coordinates.length; j++) {
                                const dist = Math.sqrt(
                                    Math.pow(route.coordinates[j].lat - segmentStart.lat, 2) +
                                    Math.pow(route.coordinates[j].lon - segmentStart.lon, 2)
                                );
                                if (dist < minDist) {
                                    minDist = dist;
                                    startIdx = j;
                                }
                            }
                        }
                        
                        if (i === allPoints.length - 2) {
                            endIdx = route.coordinates.length - 1;
                        } else {
                            // Find closest point to next waypoint
                            let minDist = Infinity;
                            for (let j = startIdx; j < route.coordinates.length; j++) {
                                const dist = Math.sqrt(
                                    Math.pow(route.coordinates[j].lat - segmentEnd.lat, 2) +
                                    Math.pow(route.coordinates[j].lon - segmentEnd.lon, 2)
                                );
                                if (dist < minDist) {
                                    minDist = dist;
                                    endIdx = j;
                                }
                            }
                        }
                        
                        // Get middle point from this segment of actual geometry
                        const midIdx = Math.floor((startIdx + endIdx) / 2);
                        const midPoint = route.coordinates[midIdx];

                        const midMarker = L.marker([midPoint.lat, midPoint.lon], {
                            icon: L.divIcon({
                                className: 'midpoint-marker',
                                html: '<div style="width: 10px; height: 10px; background: rgba(255,193,7,0.8); border: 2px solid white; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></div>',
                                iconSize: [10, 10]
                            }),
                            opacity: 0.7
                        }).addTo(map);

                        midMarker.on('click', async () => {
                            // Check if we haven't exceeded 15 waypoints limit
                            const currentWaypoints = route.waypoints || [];
                            if (currentWaypoints.length >= 15) {
                                alert('Maxim√°ln√≠ poƒçet pr≈Øjezdn√≠ch bod≈Ø je 15');
                                return;
                            }

                            // Insert new waypoint at the middle point of actual geometry
                            const newWaypoint = { lat: midPoint.lat, lon: midPoint.lon };
                            const updatedWaypoints = [...currentWaypoints];
                            updatedWaypoints.splice(i, 0, newWaypoint);
                            
                            route.waypoints = updatedWaypoints;
                            
                            if (!tempRouteData) {
                                tempRouteData = {
                                    start: { lat: firstCoord.lat, lon: firstCoord.lon },
                                    end: { lat: lastCoord.lat, lon: lastCoord.lon },
                                    waypoints: updatedWaypoints
                                };
                            } else {
                                tempRouteData.waypoints = updatedWaypoints;
                            }
                            
                            await recalculateRoutingRoute();
                        });

                        markers.push(midMarker);
                    }
                } else {
                    // Manual mode - show all vertex markers
                    route.coordinates.forEach((coord, index) => {
                        const marker = L.marker([coord.lat, coord.lon], {
                            draggable: true,
                            icon: L.divIcon({
                                className: 'vertex-marker',
                                html: '<div style="width: 14px; height: 14px; background: white; border: 3px solid ' + color + '; border-radius: 50%;"></div>',
                                iconSize: [14, 14]
                            })
                        }).addTo(map);

                        marker.on('dragend', () => {
                            const latlng = marker.getLatLng();
                            route.coordinates[index] = { lat: latlng.lat, lon: latlng.lng };
                            renderRoute(route, true);
                        });

                        markers.push(marker);
                    });

                    // Add midpoint markers for adding new vertices (only in manual mode)
                    for (let i = 0; i < route.coordinates.length - 1; i++) {
                        const c1 = route.coordinates[i];
                        const c2 = route.coordinates[i + 1];
                        const midLat = (c1.lat + c2.lat) / 2;
                        const midLon = (c1.lon + c2.lon) / 2;

                        const midMarker = L.marker([midLat, midLon], {
                            icon: L.divIcon({
                                className: 'midpoint-marker',
                                html: '<div style="width: 10px; height: 10px; background: rgba(255,255,255,0.8); border: 2px solid ' + color + '; border-radius: 50%;"></div>',
                                iconSize: [10, 10]
                            }),
                            opacity: 0.7
                        }).addTo(map);

                        midMarker.on('click', () => {
                            // Insert new point at this position
                            route.coordinates.splice(i + 1, 0, { lat: midLat, lon: midLon });
                            renderRoute(route, true);
                        });

                        markers.push(midMarker);
                    }
                }
            }

            routeLayers[route.id] = { line, markers };
        }

        function renderAllRoutes() {
            routes.forEach(route => {
                const isActive = route.id === activeRouteId;
                renderRoute(route, isActive);
            });
        }

        // ======================
        // ROUTE MANAGEMENT
        // ======================
        function createRoute(coordinates = [], name = '', color = 'red', routeMode = 'manual', waypoints = []) {
            const route = {
                id: nextRouteId++,
                name,
                color,
                coordinates,
                routeMode, // 'manual' or 'routing'
                waypoints // Array of waypoint coordinates (only for routing mode): [{lat, lon}, ...]
            };
            routes.push(route);
            return route;
        }

        function activateRoute(routeId) {
            if (mode !== 'none') {
                // Don't allow activating another route while editing
                return;
            }
            activeRouteId = routeId;
            const route = routes.find(r => r.id === routeId);
            if (route) {
                // Create backup of route before editing (deep copy)
                routeBackup = {
                    id: route.id,
                    name: route.name,
                    color: route.color,
                    routeMode: route.routeMode,
                    coordinates: route.coordinates.map(c => ({ lat: c.lat, lon: c.lon })),
                    waypoints: route.waypoints ? route.waypoints.map(w => ({ lat: w.lat, lon: w.lon })) : []
                };
                
                if (route.routeMode === 'routing') {
                    mode = 'editing-routing';
                    // Initialize tempRouteData for routing mode
                    if (route.coordinates.length >= 2) {
                        tempRouteData = {
                            start: { ...route.coordinates[0] },
                            end: { ...route.coordinates[route.coordinates.length - 1] },
                            waypoints: route.waypoints ? route.waypoints.map(w => ({ ...w })) : []
                        };
                    }
                } else {
                    mode = 'editing-manual';
                }
            }
            renderAllRoutes();
            updateUI();
        }

        function deactivateRoute() {
            activeRouteId = null;
            mode = 'none';
            tempRouteData = null;
            routeBackup = null; // Clear backup
            renderAllRoutes();
            updateUI();
        }

        function cancelRouteEditing() {
            if (mode === 'editing-manual' || mode === 'editing-routing') {
                const route = routes.find(r => r.id === activeRouteId);
                // If route is empty/incomplete, delete it
                if (route && route.coordinates.length < 2) {
                    deleteRoute(activeRouteId);
                } else if (routeBackup && activeRouteId) {
                    // Restore route from backup
                    if (route) {
                        route.name = routeBackup.name;
                        route.color = routeBackup.color;
                        route.routeMode = routeBackup.routeMode;
                        route.coordinates = routeBackup.coordinates.map(c => ({ lat: c.lat, lon: c.lon }));
                        route.waypoints = routeBackup.waypoints ? routeBackup.waypoints.map(w => ({ lat: w.lat, lon: w.lon })) : [];
                    }
                }
                deactivateRoute();
            }
            
            // Clean up routing markers
            if (tempRouteData) {
                if (tempRouteData.startMarker) map.removeLayer(tempRouteData.startMarker);
                if (tempRouteData.endMarker) map.removeLayer(tempRouteData.endMarker);
                if (tempRouteData.waypointMarkers) {
                    tempRouteData.waypointMarkers.forEach(m => map.removeLayer(m));
                }
            }
        }

        function deleteRoute(routeId) {
            const index = routes.findIndex(r => r.id === routeId);
            if (index !== -1) {
                routes.splice(index, 1);
                if (routeLayers[routeId]) {
                    if (routeLayers[routeId].line) map.removeLayer(routeLayers[routeId].line);
                    if (routeLayers[routeId].markers) {
                        routeLayers[routeId].markers.forEach(m => map.removeLayer(m));
                    }
                    delete routeLayers[routeId];
                }
                if (activeRouteId === routeId) {
                    deactivateRoute();
                }
                updateUI();
            }
        }

        // ======================
        // ROUTING API
        // ======================
        async function calculateRoute(start, end, waypoints = []) {
            showLoading();
            try {
                const url = new URL('https://api.mapy.com/v1/routing/route');
                url.searchParams.set('apikey', API_KEY);
                url.searchParams.set('start', `${start.lon},${start.lat}`);
                url.searchParams.set('end', `${end.lon},${end.lat}`);
                url.searchParams.set('routeType', ROUTE_TYPE);
                url.searchParams.set('format', 'geojson');

                // Add waypoints if present (max 15)
                if (waypoints && waypoints.length > 0) {
                    const limitedWaypoints = waypoints.slice(0, 15); // API supports max 15 waypoints
                    limitedWaypoints.forEach(wp => {
                        url.searchParams.append('waypoints', `${wp.lon},${wp.lat}`);
                    });
                }

                const response = await fetch(url.toString());
                if (!response.ok) {
                    throw new Error('Nepoda≈ôilo se napl√°novat trasu');
                }

                const data = await response.json();
                
                // Extract coordinates from GeoJSON
                const coords = data.geometry.geometry.coordinates.map(c => ({
                    lon: c[0],
                    lat: c[1]
                }));

                return coords;
            } catch (error) {
                alert('Chyba p≈ôi pl√°nov√°n√≠ trasy: ' + error.message);
                return null;
            } finally {
                hideLoading();
            }
        }

        // ======================
        // GPX IMPORT/EXPORT
        // ======================
        function exportGPX() {
            if (routes.length === 0) {
                alert('≈Ω√°dn√© trasy k exportu');
                return;
            }

            let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n';
            gpx += '<gpx version="1.1" creator="MapyEditor" xmlns="http://www.topografix.com/GPX/1/1" xmlns:gpxx="http://www.garmin.com/xmlschemas/GpxExtensions/v3">\n';

            routes.forEach(route => {
                gpx += '  <trk>\n';
                gpx += `    <name>${escapeXml(route.name || 'Trasa ' + route.id)}</name>\n`;
                gpx += '    <extensions>\n';
                gpx += `      <gpxx:DisplayColor>${route.color}</gpxx:DisplayColor>\n`;
                gpx += `      <gpxx:RouteMode>${route.routeMode || 'manual'}</gpxx:RouteMode>\n`;
                
                // Save waypoints for routing mode
                if (route.routeMode === 'routing' && route.waypoints && route.waypoints.length > 0) {
                    gpx += '      <gpxx:Waypoints>\n';
                    route.waypoints.forEach(wp => {
                        gpx += `        <gpxx:Waypoint lat="${wp.lat}" lon="${wp.lon}" />\n`;
                    });
                    gpx += '      </gpxx:Waypoints>\n';
                }
                
                gpx += '    </extensions>\n';
                gpx += '    <trkseg>\n';
                route.coordinates.forEach(coord => {
                    gpx += `      <trkpt lat="${coord.lat}" lon="${coord.lon}"></trkpt>\n`;
                });
                gpx += '    </trkseg>\n';
                gpx += '  </trk>\n';
            });

            gpx += '</gpx>';

            const blob = new Blob([gpx], { type: 'application/gpx+xml' });
            
            // Try to use File System Access API for modern browsers
            if ('showSaveFilePicker' in window) {
                saveFileModern(blob);
            } else {
                // Fallback to traditional download
                saveFileFallback(blob);
            }
        }

        async function saveFileModern(blob) {
            try {
                // Generate filename with date and time
                const now = new Date();
                const year = now.getFullYear().toString().slice(-2);
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const filename = `routes_${year}${month}${day}_${hours}${minutes}.gpx`;
                
                const options = {
                    types: [{
                        description: 'GPX soubory',
                        accept: { 'application/gpx+xml': ['.gpx'] }
                    }],
                    suggestedName: filename
                };
                
                const handle = await window.showSaveFilePicker(options);
                const writable = await handle.createWritable();
                await writable.write(blob);
                await writable.close();
                
                console.log('Soubor ulo≈æen');
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Chyba p≈ôi ukl√°d√°n√≠:', err);
                    // Fallback to download
                    saveFileFallback(blob);
                }
            }
        }

        function saveFileFallback(blob) {
            // Generate filename with date and time
            const now = new Date();
            const year = now.getFullYear().toString().slice(-2);
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const filename = `routes_${year}${month}${day}_${hours}${minutes}.gpx`;
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function escapeXml(text) {
            return text.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;')
                       .replace(/'/g, '&apos;');
        }

        function importGPX(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                const tracks = xmlDoc.getElementsByTagName('trk');

                if (tracks.length === 0) {
                    return; // Silently skip files without tracks
                }

                Array.from(tracks).forEach(trk => {
                    const nameEl = trk.getElementsByTagName('name')[0];
                    const name = nameEl ? nameEl.textContent : '';
                    
                    // Try to read color, routeMode, and waypoints from extensions
                    let color = 'red'; // default
                    let routeMode = 'manual'; // default
                    let waypoints = [];
                    
                    const extensions = trk.getElementsByTagName('extensions')[0];
                    if (extensions) {
                        const displayColorEl = extensions.getElementsByTagName('gpxx:DisplayColor')[0] || 
                                               extensions.getElementsByTagName('DisplayColor')[0];
                        if (displayColorEl) {
                            const colorValue = displayColorEl.textContent.toLowerCase();
                            if (colorValue === 'red' || colorValue === 'blue' || colorValue === 'green') {
                                color = colorValue;
                            }
                        }
                        
                        const routeModeEl = extensions.getElementsByTagName('gpxx:RouteMode')[0] || 
                                           extensions.getElementsByTagName('RouteMode')[0];
                        if (routeModeEl) {
                            const modeValue = routeModeEl.textContent.toLowerCase();
                            if (modeValue === 'routing' || modeValue === 'manual') {
                                routeMode = modeValue;
                            }
                        }
                        
                        // Read waypoints
                        const waypointsEl = extensions.getElementsByTagName('gpxx:Waypoints')[0] || 
                                           extensions.getElementsByTagName('Waypoints')[0];
                        if (waypointsEl) {
                            const waypointEls = waypointsEl.getElementsByTagName('gpxx:Waypoint');
                            if (waypointEls.length === 0) {
                                // Try without namespace
                                const waypointEls2 = waypointsEl.getElementsByTagName('Waypoint');
                                Array.from(waypointEls2).forEach(wpEl => {
                                    waypoints.push({
                                        lat: parseFloat(wpEl.getAttribute('lat')),
                                        lon: parseFloat(wpEl.getAttribute('lon'))
                                    });
                                });
                            } else {
                                Array.from(waypointEls).forEach(wpEl => {
                                    waypoints.push({
                                        lat: parseFloat(wpEl.getAttribute('lat')),
                                        lon: parseFloat(wpEl.getAttribute('lon'))
                                    });
                                });
                            }
                        }
                    }
                    
                    const trkpts = trk.getElementsByTagName('trkpt');
                    const coordinates = Array.from(trkpts).map(pt => ({
                        lat: parseFloat(pt.getAttribute('lat')),
                        lon: parseFloat(pt.getAttribute('lon'))
                    }));

                    if (coordinates.length > 0) {
                        createRoute(coordinates, name, color, routeMode, waypoints);
                    }
                });

                renderAllRoutes();
                updateUI();
                
                // Fit bounds to all routes
                fitBoundsToRoutes();
            };
            reader.readAsText(file);
        }

        function importMultipleGPX(files) {
            const dropzoneContent = document.querySelector('.dropzone-content');
            const dropzoneLoading = document.getElementById('dropzone-loading');
            
            // Show loading
            dropzoneContent.style.display = 'none';
            dropzoneLoading.style.display = 'flex';
            
            let processed = 0;
            const totalFiles = files.length;
            
            Array.from(files).forEach((file, index) => {
                if (file.name.toLowerCase().endsWith('.gpx')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                        const tracks = xmlDoc.getElementsByTagName('trk');

                        Array.from(tracks).forEach(trk => {
                            const nameEl = trk.getElementsByTagName('name')[0];
                            const name = nameEl ? nameEl.textContent : file.name.replace('.gpx', '');
                            
                            let color = 'red';
                            let routeMode = 'manual';
                            let waypoints = [];
                            
                            const extensions = trk.getElementsByTagName('extensions')[0];
                            if (extensions) {
                                const displayColorEl = extensions.getElementsByTagName('gpxx:DisplayColor')[0] || 
                                                       extensions.getElementsByTagName('DisplayColor')[0];
                                if (displayColorEl) {
                                    const colorValue = displayColorEl.textContent.toLowerCase();
                                    if (colorValue === 'red' || colorValue === 'blue' || colorValue === 'green') {
                                        color = colorValue;
                                    }
                                }
                                
                                const routeModeEl = extensions.getElementsByTagName('gpxx:RouteMode')[0] || 
                                                   extensions.getElementsByTagName('RouteMode')[0];
                                if (routeModeEl) {
                                    const modeValue = routeModeEl.textContent.toLowerCase();
                                    if (modeValue === 'routing' || modeValue === 'manual') {
                                        routeMode = modeValue;
                                    }
                                }
                                
                                const waypointsEl = extensions.getElementsByTagName('gpxx:Waypoints')[0] || 
                                                   extensions.getElementsByTagName('Waypoints')[0];
                                if (waypointsEl) {
                                    const waypointEls = waypointsEl.getElementsByTagName('gpxx:Waypoint');
                                    if (waypointEls.length === 0) {
                                        const waypointEls2 = waypointsEl.getElementsByTagName('Waypoint');
                                        Array.from(waypointEls2).forEach(wpEl => {
                                            waypoints.push({
                                                lat: parseFloat(wpEl.getAttribute('lat')),
                                                lon: parseFloat(wpEl.getAttribute('lon'))
                                            });
                                        });
                                    } else {
                                        Array.from(waypointEls).forEach(wpEl => {
                                            waypoints.push({
                                                lat: parseFloat(wpEl.getAttribute('lat')),
                                                lon: parseFloat(wpEl.getAttribute('lon'))
                                            });
                                        });
                                    }
                                }
                            }
                            
                            const trkpts = trk.getElementsByTagName('trkpt');
                            const coordinates = Array.from(trkpts).map(pt => ({
                                lat: parseFloat(pt.getAttribute('lat')),
                                lon: parseFloat(pt.getAttribute('lon'))
                            }));

                            if (coordinates.length > 0) {
                                createRoute(coordinates, name, color, routeMode, waypoints);
                            }
                        });

                        processed++;
                        if (processed === totalFiles) {
                            // All files processed
                            renderAllRoutes();
                            updateUI();
                            fitBoundsToRoutes();
                            
                            // Hide loading and close import panel
                            setTimeout(() => {
                                dropzoneLoading.style.display = 'none';
                                dropzoneContent.style.display = 'block';
                                // Close import panel after successful import
                                setTimeout(() => {
                                    document.getElementById('import-panel').style.display = 'none';
                                }, 500);
                            }, 300);
                        }
                    };
                    reader.onerror = () => {
                        processed++;
                        if (processed === totalFiles) {
                            dropzoneLoading.style.display = 'none';
                            dropzoneContent.style.display = 'block';
                            setTimeout(() => {
                                document.getElementById('import-panel').style.display = 'none';
                            }, 500);
                        }
                    };
                    reader.readAsText(file);
                } else {
                    processed++;
                    if (processed === totalFiles) {
                        dropzoneLoading.style.display = 'none';
                        dropzoneContent.style.display = 'block';
                        setTimeout(() => {
                            document.getElementById('import-panel').style.display = 'none';
                        }, 500);
                    }
                }
            });
        }

        function fitBoundsToRoutes() {
            if (routes.length === 0) return;
            
            const allCoords = [];
            routes.forEach(route => {
                route.coordinates.forEach(coord => {
                    allCoords.push([coord.lat, coord.lon]);
                });
            });
            
            if (allCoords.length > 0) {
                const bounds = L.latLngBounds(allCoords);
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }

        // ======================
        // MAP INTERACTIONS
        // ======================
        map.on('click', async (e) => {
            const route = routes.find(r => r.id === activeRouteId);
            if (!route) return;
            
            // Manual route mode
            if (mode === 'editing-manual') {
                // Allow adding points:
                // - Always if less than 2 points (initial creation)
                // - With CTRL if 2+ points exist
                if (route.coordinates.length < 2 || ctrlPressed) {
                    route.coordinates.push({
                        lat: e.latlng.lat,
                        lon: e.latlng.lng
                    });
                    renderRoute(route, true);
                    updateUI();
                }
            }
            
            // Routing mode
            else if (mode === 'editing-routing') {
                const numPoints = route.coordinates.length;
                
                // First two points don't need CTRL
                if (numPoints === 0) {
                    // Add start point
                    route.coordinates.push({
                        lat: e.latlng.lat,
                        lon: e.latlng.lng
                    });
                    if (!tempRouteData) {
                        tempRouteData = { waypoints: [] };
                    }
                    renderRoute(route, true);
                    updateUI();
                }
                else if (numPoints === 1) {
                    // Add end point and calculate initial route
                    const start = route.coordinates[0];
                    const end = { lat: e.latlng.lat, lon: e.latlng.lng };
                    
                    tempRouteData = {
                        start: { ...start },
                        end: { ...end },
                        waypoints: []
                    };
                    
                    const coords = await calculateRoute(tempRouteData.start, tempRouteData.end, []);
                    if (coords) {
                        route.coordinates = coords;
                        route.waypoints = [];
                        renderRoute(route, true);
                        updateUI();
                    }
                }
                // Further points need CTRL - extend route
                else if (ctrlPressed) {
                    // Check waypoint limit
                    const currentWaypoints = route.waypoints || [];
                    if (currentWaypoints.length >= 15) {
                        alert('Maxim√°ln√≠ poƒçet pr≈Øjezdn√≠ch bod≈Ø je 15');
                        return;
                    }
                    
                    // Current end becomes last waypoint
                    const currentEnd = route.coordinates[route.coordinates.length - 1];
                    const newWaypoints = [...currentWaypoints, { lat: currentEnd.lat, lon: currentEnd.lon }];
                    
                    // New click becomes new end
                    const newEnd = { lat: e.latlng.lat, lon: e.latlng.lng };
                    
                    // Update tempRouteData
                    tempRouteData.end = newEnd;
                    tempRouteData.waypoints = newWaypoints;
                    
                    // Recalculate route
                    const coords = await calculateRoute(tempRouteData.start, tempRouteData.end, tempRouteData.waypoints);
                    if (coords) {
                        route.coordinates = coords;
                        route.waypoints = newWaypoints;
                        renderRoute(route, true);
                        updateUI();
                    }
                }
            }
        });

        async function recalculateRoutingRoute() {
            const coords = await calculateRoute(tempRouteData.start, tempRouteData.end, tempRouteData.waypoints || []);
            if (coords) {
                const route = routes.find(r => r.id === activeRouteId);
                if (route) {
                    route.coordinates = coords;
                    route.waypoints = tempRouteData.waypoints || [];
                    renderRoute(route, true);
                }
            }
        }

        // ======================
        // BUTTON HANDLERS
        // ======================
        document.getElementById('btn-create-manual').addEventListener('click', () => {
            if (activeRouteId) {
                deactivateRoute();
            }
            const route = createRoute([], 'Nov√° trasa', 'red', 'manual', []);
            activateRoute(route.id);
        });

        document.getElementById('btn-create-routing').addEventListener('click', () => {
            if (activeRouteId) {
                deactivateRoute();
            }
            const route = createRoute([], 'Nov√° trasa', 'red', 'routing', []);
            activateRoute(route.id);
        });

        document.getElementById('btn-save-route').addEventListener('click', () => {
            // Clean up routing markers
            if (tempRouteData) {
                if (tempRouteData.startMarker) map.removeLayer(tempRouteData.startMarker);
                if (tempRouteData.endMarker) map.removeLayer(tempRouteData.endMarker);
                tempRouteData = null;
            }
            deactivateRoute();
        });

        document.getElementById('btn-cancel-route').addEventListener('click', () => {
            cancelRouteEditing();
        });

        // ======================
        // DRAG & DROP / FILE UPLOAD HANDLERS
        // ======================
        const dropzone = document.getElementById('dropzone');
        const gpxInput = document.getElementById('gpx-input');
        const importPanel = document.getElementById('import-panel');

        // Show import panel
        document.getElementById('btn-import-gpx').addEventListener('click', () => {
            if (mode === 'none') {
                importPanel.style.display = 'block';
                dropzone.classList.add('visible');
            }
        });

        // Hide import panel
        document.getElementById('btn-close-import').addEventListener('click', () => {
            importPanel.style.display = 'none';
            dropzone.classList.remove('visible');
        });

        // Click to select files
        dropzone.addEventListener('click', () => {
            if (mode === 'none') {
                gpxInput.click();
            }
        });

        // Handle file selection
        gpxInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importMultipleGPX(e.target.files);
                // Reset input
                e.target.value = '';
            }
        });

        // Drag & Drop handlers
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (mode === 'none') {
                dropzone.classList.add('dragover');
            }
        });

        dropzone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
        });

        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
            
            if (mode === 'none') {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    importMultipleGPX(files);
                }
            }
        });

        document.getElementById('btn-export-gpx').addEventListener('click', () => {
            exportGPX();
        });

        // ======================
        // ATTRIBUTE HANDLERS
        // ======================
        routeNameInput.addEventListener('input', () => {
            const route = routes.find(r => r.id === activeRouteId);
            if (route) {
                route.name = routeNameInput.value;
                updateUI();
            }
        });

        routeColorSelect.addEventListener('change', () => {
            const route = routes.find(r => r.id === activeRouteId);
            if (route) {
                route.color = routeColorSelect.value;
                renderRoute(route, true);
            }
        });

        // ======================
        // INITIALIZATION
        // ======================
        
        // CTRL key tracking for adding points
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Control' || e.ctrlKey) {
                ctrlPressed = true;
                updateUI();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Control' || !e.ctrlKey) {
                ctrlPressed = false;
                updateUI();
            }
        });

        // Reset CTRL state when window loses focus
        window.addEventListener('blur', () => {
            ctrlPressed = false;
            updateUI();
        });

        updateUI();
    </script>
</body>
</html>

