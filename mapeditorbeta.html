<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapyEditor Beta - Editor tras</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #1a1a1a;
        }

        #app {
            display: flex;
            height: 100vh;
        }

        #map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        #map.add-routing-mode {
            cursor: copy !important;
        }

        #map.add-routing-mode * {
            cursor: copy !important;
        }

        #map.add-manual-mode {
            cursor: crosshair !important;
        }

        #map.add-manual-mode * {
            cursor: crosshair !important;
        }

        #map.add-start-mode {
            cursor: crosshair !important;
        }

        #map.add-start-mode * {
            cursor: crosshair !important;
        }

        #status-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 8px 16px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 14px;
            font-weight: 500;
        }

        #right-panel {
            width: 400px;
            background: #2d2d2d;
            padding: 20px;
            overflow-y: hidden;
            border-left: 1px solid #1a1a1a;
            display: flex;
            flex-direction: column;
        }

        .panel-section {
            background: #3a3a3a;
            padding: 16px;
            margin-bottom: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }

        .panel-section h3 {
            margin-bottom: 12px;
            font-size: 16px;
            color: #e0e0e0;
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            justify-content: space-between;
        }

        .panel-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-header-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #FF9800, #4CAF50);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .panel-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #e0e0e0;
        }

        .about-link {
            color: #FF9800;
            text-decoration: none;
            font-size: 13px;
            transition: color 0.2s;
            white-space: nowrap;
        }

        .about-link:hover {
            color: #4CAF50;
        }

        .version-badge {
            background: linear-gradient(135deg, #FF9800, #F57C00);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .info-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-label {
            font-weight: 500;
            color: #b0b0b0;
        }

        .info-value {
            color: #e0e0e0;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button.primary {
            background: #FF9800;
            color: white;
        }

        button.primary:hover {
            background: #F57C00;
        }

        button.success {
            background: #4CAF50;
            color: white;
        }

        button.success:hover {
            background: #388E3C;
        }

        button.secondary {
            background: #757575;
            color: white;
        }

        button.secondary:hover {
            background: #616161;
        }

        button.warning {
            background: #F57C00;
            color: white;
        }

        button.warning:hover {
            background: #E65100;
        }

        button.muted {
            background: #616161;
            color: #e0e0e0;
        }

        button.muted:hover {
            background: #757575;
        }

        .button-row {
            display: flex;
            gap: 8px;
        }

        .button-row button {
            margin-bottom: 0;
        }

        .button-row .btn-main {
            flex: 2;
        }

        .button-row .btn-secondary {
            flex: 1;
        }

        .button-compact {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .button-compact button {
            flex: 1;
            margin-bottom: 0;
            font-size: 13px;
            padding: 8px;
        }

        .button-compact button svg {
            vertical-align: middle;
            margin-right: 4px;
        }

        .toolbar {
            display: flex;
            gap: 6px;
        }

        .toolbar button {
            flex: 1;
            margin-bottom: 0;
            font-size: 12px;
            padding: 8px 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .toolbar button svg {
            flex-shrink: 0;
        }

        button:disabled {
            background: #e0e0e0 !important;
            color: #9e9e9e !important;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
            font-weight: 500;
            color: #e0e0e0;
        }

        .form-group input[type="text"],
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
            background: #2d2d2d;
            color: #e0e0e0;
        }

        .form-group input[type="text"]:focus,
        .form-group select:focus {
            outline: none;
            border-color: #FF9800;
        }

        input[type="file"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 14px;
            background: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
        }

        .dropzone {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #2d2d2d;
            margin-bottom: 12px;
            display: none;
        }

        .dropzone.visible {
            display: block;
        }

        .dropzone:hover {
            border-color: #FF9800;
            background: #353535;
        }

        .dropzone.dragover {
            border-color: #4CAF50;
            background: #2d4030;
            transform: scale(1.02);
        }

        .dropzone-content {
            pointer-events: none;
        }

        .dropzone svg {
            color: #b0b0b0;
            margin-bottom: 12px;
        }

        .dropzone-text {
            color: #e0e0e0;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .dropzone-hint {
            color: #888;
            font-size: 12px;
            margin: 0;
        }

        .leaflet-marker-icon.vertex-marker {
            cursor: pointer !important;
        }

        .leaflet-marker-icon.midpoint-marker {
            cursor: copy !important;
        }

        .leaflet-marker-icon.hover-midpoint-marker {
            cursor: copy !important;
            pointer-events: auto !important;
        }

        .leaflet-interactive:focus {
            outline: none !important;
        }
        
        .leaflet-interactive:focus-visible {
            outline: none !important;
        }

        .dropzone-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .dropzone-loading p {
            color: #e0e0e0;
            margin-top: 12px;
            font-size: 14px;
        }

        .spinner {
            border: 3px solid #555;
            border-top: 3px solid #FF9800;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 16px 24px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
        }

        .route-tooltip {
            background: rgba(0, 0, 0, 0.85) !important;
            border: 1px solid #444 !important;
            color: #e0e0e0 !important;
            font-size: 13px !important;
            padding: 6px 10px !important;
            border-radius: 4px !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
        }

        .route-tooltip::before {
            border-top-color: rgba(0, 0, 0, 0.85) !important;
        }

        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            padding: 4px 0;
            z-index: 10000;
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #333;
            transition: background-color 0.2s;
        }

        .context-menu-item:hover {
            background-color: #f0f0f0;
        }

        .context-menu-item svg {
            width: 16px;
            height: 16px;
        }
        
        .context-menu-item.delete svg {
            color: #D32F2F;
        }
        
        .context-menu-item.split svg {
            color: #2196F3;
        }

        .context-menu-item.mode-routing svg {
            color: #FFC107;
        }

        .context-menu-item.mode-manual svg {
            color: #9E9E9E;
        }

        .context-menu-separator {
            height: 1px;
            background: #e0e0e0;
            margin: 4px 0;
        }

        /* Panel header with menu */
        .panel-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .panel-header-row h3 {
            margin: 0;
        }

        .panel-menu-container {
            position: relative;
        }

        .panel-menu-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-menu-btn:hover {
            background: #e0e0e0;
            color: #333;
        }

        .panel-menu {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
            min-width: 150px;
        }

        .panel-menu.visible {
            display: block;
        }

        .panel-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
        }

        .panel-menu-item:hover {
            background-color: #f0f0f0;
        }

        .panel-menu-item svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .panel-menu-item.delete {
            color: #D32F2F;
        }

        .panel-menu-item.delete svg {
            color: #D32F2F;
        }

        .help-hint {
            font-size: 12px;
            color: #b0b0b0;
            margin-top: 8px;
            line-height: 1.5;
        }

        .help-hint-item {
            margin-bottom: 4px;
        }

        .help-hint-item .key {
            background: #555;
            color: #fff;
            padding: 1px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
        }

        #routes-list-container {
            flex: 1;
            overflow-y: auto;
            background: #3a3a3a;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
        }

        #routes-list-container.hidden {
            display: none;
        }

        .routes-search {
            padding: 16px;
            border-bottom: 1px solid #555;
            flex-shrink: 0;
        }

        .routes-search h3 {
            margin-bottom: 12px;
            font-size: 16px;
            color: #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .routes-count {
            font-size: 14px;
            color: #888;
            font-weight: normal;
        }

        .search-box {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .search-box input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
            background: #2d2d2d;
            color: #e0e0e0;
        }

        .search-box input:focus {
            outline: none;
            border-color: #FF9800;
        }

        .routes-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .route-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #2d2d2d;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .route-item:hover {
            background: #353535;
            transform: translateX(4px);
        }

        .route-color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }

        .route-item-text {
            flex: 1;
            min-width: 0;
        }

        .route-item-name {
            font-size: 14px;
            font-weight: 500;
            color: #e0e0e0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .route-item-info {
            font-size: 12px;
            color: #888;
            margin-top: 2px;
        }

        .routes-list-empty {
            padding: 40px 20px;
            text-align: center;
            color: #888;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            #app {
                flex-direction: column;
            }

            #map-container {
                height: 60vh;
            }

            #right-panel {
                width: 100%;
                height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="map-container">
            <div id="status-bar">Nevybran√° trasa</div>
            <div id="map"></div>
            <div id="loading-indicator">Pl√°nuji trasu...</div>
            <div id="context-menu" class="context-menu">
                <div class="context-menu-item delete" id="context-menu-delete">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                    Smazat bod
                </div>
                <div class="context-menu-item split" id="context-menu-split">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="6" cy="6" r="3"></circle>
                        <circle cx="6" cy="18" r="3"></circle>
                        <line x1="20" y1="4" x2="8.12" y2="15.88"></line>
                        <line x1="14.47" y1="14.48" x2="20" y2="20"></line>
                        <line x1="8.12" y1="8.12" x2="12" y2="12"></line>
                    </svg>
                    Rozdƒõlit trasu
                </div>
                <div class="context-menu-separator"></div>
                <div class="context-menu-item mode-routing" id="context-menu-mode-routing">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                    Zmƒõnit na pl√°nov√°n√≠
                </div>
                <div class="context-menu-item mode-manual" id="context-menu-mode-manual">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 20h9"></path>
                        <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                    </svg>
                    Zmƒõnit na ruƒçn√≠
                </div>
            </div>
        </div>
        <div id="right-panel">
            <div class="panel-section">
                <div class="panel-header">
                    <div class="panel-header-left">
                        <div class="panel-header-icon">üó∫Ô∏è</div>
                        <h3>MapyEditor</h3>
                        <span class="version-badge">BETA</span>
                    </div>
                    <a href="About.html" class="about-link" target="_blank">‚ÑπÔ∏è O programu</a>
                </div>
                <div class="toolbar" style="margin-top: 12px;">
                    <button class="primary" id="btn-create-route" title="Nov√° trasa">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        Nov√°
                    </button>
                    <button class="secondary" id="btn-import-gpx" title="Nahr√°t GPX">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                        </svg>
                        Nahr√°t
                    </button>
                    <button class="secondary" id="btn-export-gpx" title="Ulo≈æit GPX">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                            <polyline points="17 21 17 13 7 13 7 21"></polyline>
                            <polyline points="7 3 7 8 15 8"></polyline>
                        </svg>
                        Ulo≈æit
                    </button>
                </div>
            </div>

            <div class="panel-section" id="import-panel" style="display: none;">
                <h3>Import GPX</h3>
                <div id="dropzone" class="dropzone">
                    <div class="dropzone-content">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        <p class="dropzone-text">P≈ôet√°hnƒõte GPX soubory nebo kliknƒõte pro v√Ωbƒõr</p>
                        <p class="dropzone-hint">Podporuje v√≠ce soubor≈Ø najednou</p>
                    </div>
                    <div id="dropzone-loading" class="dropzone-loading" style="display: none;">
                        <div class="spinner"></div>
                        <p>Naƒç√≠t√°m trasy...</p>
                    </div>
                    <input type="file" id="gpx-input" accept=".gpx" multiple style="display: none;">
                </div>
                <button class="secondary" id="btn-close-import" style="width: 100%;">Zav≈ô√≠t</button>
            </div>

            <!-- Routes List Container -->
            <div id="routes-list-container">
                <div class="routes-search">
                    <h3>Seznam tras <span class="routes-count" id="routes-count">0/0</span></h3>
                    <div class="search-box">
                        <input type="text" id="route-search-input" placeholder="Hledat trasu...">
                    </div>
                </div>
                <div class="routes-list" id="routes-list">
                    <div class="routes-list-empty">Zat√≠m nejsou vytvo≈ôeny ≈æ√°dn√© trasy</div>
                </div>
            </div>

            <div class="panel-section" id="attributes-panel" style="display: none;">
                <div class="panel-header-row">
                    <h3>Editace trasy</h3>
                    <div class="panel-menu-container">
                        <button class="panel-menu-btn" id="route-menu-btn" title="Menu trasy">
                            <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                                <circle cx="12" cy="5" r="2"></circle>
                                <circle cx="12" cy="12" r="2"></circle>
                                <circle cx="12" cy="19" r="2"></circle>
                            </svg>
                        </button>
                        <div class="panel-menu" id="route-menu">
                            <div class="panel-menu-item delete" id="menu-delete-route">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                </svg>
                                Smazat trasu
                            </div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="route-name">N√°zev</label>
                    <input type="text" id="route-name" placeholder="N√°zev trasy">
                </div>
                <div class="form-group">
                    <label for="route-color">Barva</label>
                    <select id="route-color">
                        <option value="red">ƒåerven√°</option>
                        <option value="blue">Modr√°</option>
                        <option value="green">Zelen√°</option>
                    </select>
                </div>
                <div class="button-row">
                    <button class="success btn-main" id="btn-save-route" disabled>Ulo≈æit trasu</button>
                    <button class="muted btn-secondary" id="btn-cancel-route" disabled>Storno</button>
                </div>
                <div class="help-hint">
                    <div class="help-hint-item">üí° <span class="key">CTRL</span> + klik ‚Äì p≈ôid√° pl√°novan√Ω bod</div>
                    <div class="help-hint-item">üí° <span class="key">ALT</span> + klik ‚Äì p≈ôid√° ruƒçn√≠ bod</div>
                    <div class="help-hint-item">üí° <strong>Prav√© tlaƒç√≠tko</strong> ‚Äì menu bodu</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================
        // CONFIGURATION
        // ======================
        const CONFIG = {
            API_KEY: 'eyJpIjo1LCJjIjoxNjM3MjMxMTY1fQ.wQ9-T6PhNT85YhqKRZPbp-iAIosTyIDfdw_ADBdUrn0',
            ROUTE_TYPE: 'foot_fast',
            MAX_WAYPOINTS_PER_API_CALL: 15,
            KEYS: {
                ROUTING: 'Control',
                MANUAL: 'Alt'
            }
        };

        const colorMap = {
            red: '#D32F2F',
            blue: '#1976D2',
            green: '#388E3C'
        };

        // ======================
        // DATA MODEL
        // ======================
        let routes = [];
        let nextRouteId = 1;
        let activeRouteId = null;
        let isEditing = false;
        let routeBackup = null;
        let routeSearchQuery = '';
        
        // Key state tracking
        let ctrlPressed = false;
        let altPressed = false;
        
        // Context menu data
        let contextMenuData = null;
        
        // Hover marker for adding midpoints
        let hoverMarker = null;
        let hoverMarkerData = null; // { segmentIndex, lat, lon, insertIndex, mode }

        // ======================
        // MAP INITIALIZATION
        // ======================
        const map = L.map('map').setView([49.8729317, 14.8981184], 8);

        const tileLayers = {
            'Z√°kladn√≠': L.tileLayer(`https://api.mapy.com/v1/maptiles/basic/256/{z}/{x}/{y}?apikey=${CONFIG.API_KEY}`, {
                minZoom: 0,
                maxZoom: 20,
                attribution: '<a href="https://api.mapy.com/copyright" target="_blank">&copy; Seznam.cz a.s. a dal≈°√≠</a>',
            }),
            'Turistick√°': L.tileLayer(`https://api.mapy.com/v1/maptiles/outdoor/256/{z}/{x}/{y}?apikey=${CONFIG.API_KEY}`, {
                minZoom: 0,
                maxZoom: 20,
                attribution: '<a href="https://api.mapy.com/copyright" target="_blank">&copy; Seznam.cz a.s. a dal≈°√≠</a>',
            }),
            'Zimn√≠': L.tileLayer(`https://api.mapy.com/v1/maptiles/winter/256/{z}/{x}/{y}?apikey=${CONFIG.API_KEY}`, {
                minZoom: 0,
                maxZoom: 20,
                attribution: '<a href="https://api.mapy.com/copyright" target="_blank">&copy; Seznam.cz a.s. a dal≈°√≠</a>',
            }),
            'Leteck√°': L.tileLayer(`https://api.mapy.com/v1/maptiles/aerial/256/{z}/{x}/{y}?apikey=${CONFIG.API_KEY}`, {
                minZoom: 0,
                maxZoom: 20,
                attribution: '<a href="https://api.mapy.com/copyright" target="_blank">&copy; Seznam.cz a.s. a dal≈°√≠</a>',
            }),
        };

        tileLayers['Z√°kladn√≠'].addTo(map);
        L.control.layers(tileLayers).addTo(map);

        // Apply grayscale filter to Basic map layer
        setTimeout(() => {
            const container = tileLayers['Z√°kladn√≠'].getContainer();
            if (container) {
                container.style.filter = 'grayscale(90%) opacity(60%)';
            }
        }, 100);

        map.on('baselayerchange', function(e) {
            if (e.name === 'Z√°kladn√≠') {
                setTimeout(() => {
                    const container = tileLayers['Z√°kladn√≠'].getContainer();
                    if (container) {
                        container.style.filter = 'grayscale(90%) opacity(60%)';
                    }
                }, 50);
            }
        });

        // Add logo control
        const LogoControl = L.Control.extend({
            options: { position: 'bottomleft' },
            onAdd: function (map) {
                const container = L.DomUtil.create('div');
                const link = L.DomUtil.create('a', '', container);
                link.setAttribute('href', 'http://mapy.com/');
                link.setAttribute('target', '_blank');
                link.innerHTML = '<img src="https://api.mapy.com/img/api/logo.svg" />';
                L.DomEvent.disableClickPropagation(link);
                return container;
            },
        });
        new LogoControl().addTo(map);

        // ======================
        // LAYERS & MARKERS
        // ======================
        const routeLayers = {}; // routeId -> { lines, markers }

        // ======================
        // UI ELEMENTS
        // ======================
        const statusBar = document.getElementById('status-bar');
        const loadingIndicator = document.getElementById('loading-indicator');
        const attributesPanel = document.getElementById('attributes-panel');
        const routeNameInput = document.getElementById('route-name');
        const routeColorSelect = document.getElementById('route-color');

        // ======================
        // HELPER FUNCTIONS
        // ======================
        function showLoading() {
            loadingIndicator.style.display = 'block';
        }

        function hideLoading() {
            loadingIndicator.style.display = 'none';
        }

        function getColorHex(colorName) {
            return colorMap[colorName] || colorMap.red;
        }

        function updateUI() {
            const mapElement = document.getElementById('map');
            const route = activeRouteId ? routes.find(r => r.id === activeRouteId) : null;
            
            // Update map cursor based on state
            mapElement.classList.remove('add-routing-mode', 'add-manual-mode', 'add-start-mode');
            
            if (isEditing && route) {
                if (route.waypoints.length === 0) {
                    // Need to add start point
                    mapElement.classList.add('add-start-mode');
                } else if (ctrlPressed) {
                    mapElement.classList.add('add-routing-mode');
                } else if (altPressed) {
                    mapElement.classList.add('add-manual-mode');
                }
            }
            
            // Disable/enable buttons based on mode
            document.getElementById('btn-create-route').disabled = isEditing;
            document.getElementById('btn-export-gpx').disabled = isEditing;
            document.getElementById('btn-import-gpx').disabled = isEditing;
            
            // Show/hide routes list and attributes panel
            const routesListContainer = document.getElementById('routes-list-container');
            
            if (activeRouteId && isEditing) {
                // Update status bar
                if (route.waypoints.length === 0) {
                    statusBar.textContent = `Nov√° trasa: ${route.name || 'Bez n√°zvu'} - kliknƒõte pro start`;
                } else {
                    const wpCount = route.waypoints.length;
                    statusBar.textContent = `√öprava trasy: ${route.name || 'Bez n√°zvu'} (${wpCount} bod≈Ø)`;
                }
                
                // Hide routes list, show attributes panel
                routesListContainer.classList.add('hidden');
                attributesPanel.style.display = 'block';
                routeNameInput.value = route ? route.name : '';
                routeColorSelect.value = route ? route.color : 'red';
                
                // Enable save and cancel buttons
                document.getElementById('btn-save-route').disabled = false;
                document.getElementById('btn-cancel-route').disabled = false;
            } else {
                statusBar.textContent = 'Nevybran√° trasa';
                
                // Show routes list, hide attributes panel
                routesListContainer.classList.remove('hidden');
                attributesPanel.style.display = 'none';
                document.getElementById('btn-save-route').disabled = true;
                document.getElementById('btn-cancel-route').disabled = true;
                
                // Update routes list
                updateRoutesList();
            }
        }

        function updateRoutesList() {
            const routesList = document.getElementById('routes-list');
            const routesCountEl = document.getElementById('routes-count');
            
            // Filter routes based on search query
            const filteredRoutes = routes.filter(route => {
                if (!routeSearchQuery) return true;
                const name = route.name || '';
                return name.toLowerCase().includes(routeSearchQuery.toLowerCase());
            });
            
            // Update count display
            routesCountEl.textContent = `${filteredRoutes.length}/${routes.length}`;
            
            if (filteredRoutes.length === 0) {
                if (routes.length === 0) {
                    routesList.innerHTML = '<div class="routes-list-empty">Zat√≠m nejsou vytvo≈ôeny ≈æ√°dn√© trasy</div>';
                } else {
                    routesList.innerHTML = '<div class="routes-list-empty">≈Ω√°dn√© trasy odpov√≠daj√≠c√≠ hled√°n√≠</div>';
                }
                return;
            }
            
            routesList.innerHTML = '';
            filteredRoutes.forEach(route => {
                const routeItem = document.createElement('div');
                routeItem.className = 'route-item';
                routeItem.dataset.routeId = route.id;
                
                const colorIndicator = document.createElement('div');
                colorIndicator.className = 'route-color-indicator';
                colorIndicator.style.backgroundColor = getColorHex(route.color);
                
                const textDiv = document.createElement('div');
                textDiv.className = 'route-item-text';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'route-item-name';
                nameDiv.textContent = route.name || 'Bez n√°zvu';
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'route-item-info';
                infoDiv.textContent = `${route.waypoints.length} bod≈Ø`;
                
                textDiv.appendChild(nameDiv);
                textDiv.appendChild(infoDiv);
                
                routeItem.appendChild(colorIndicator);
                routeItem.appendChild(textDiv);
                
                // Click handler - activate route with bestfit
                routeItem.addEventListener('click', () => {
                    activateRouteWithBestFit(route.id);
                });
                
                // Hover handler - highlight route in map
                routeItem.addEventListener('mouseenter', () => {
                    highlightRouteInMap(route.id, true);
                });
                
                routeItem.addEventListener('mouseleave', () => {
                    highlightRouteInMap(route.id, false);
                });
                
                routesList.appendChild(routeItem);
            });
        }

        function highlightRouteInMap(routeId, highlight) {
            if (isEditing) return;
            
            const layer = routeLayers[routeId];
            if (layer && layer.lines) {
                layer.lines.forEach(line => {
                    if (highlight) {
                        line.setStyle({ weight: 8, opacity: 1 });
                    } else {
                        line.setStyle({ weight: 5, opacity: 0.95 });
                    }
                });
            }
        }

        // ======================
        // SEGMENT LOGIC
        // ======================
        
        /**
         * Analyze waypoints and create segment definitions
         * A segment is a continuous sequence of waypoints with the same mode
         * Routing segments are split if they exceed MAX_WAYPOINTS_PER_API_CALL
         */
        function analyzeSegments(waypoints) {
            if (waypoints.length < 2) return [];
            
            const segments = [];
            let currentSegment = null;
            
            for (let i = 1; i < waypoints.length; i++) {
                const wp = waypoints[i];
                const mode = wp.mode;
                
                if (!currentSegment || currentSegment.mode !== mode) {
                    // Start new segment
                    if (currentSegment) {
                        segments.push(currentSegment);
                    }
                    currentSegment = {
                        mode: mode,
                        startIndex: i - 1,  // Index of first waypoint
                        endIndex: i,        // Index of last waypoint (will be updated)
                        waypointIndices: [i - 1, i]
                    };
                } else {
                    // Continue current segment
                    currentSegment.endIndex = i;
                    currentSegment.waypointIndices.push(i);
                }
            }
            
            if (currentSegment) {
                segments.push(currentSegment);
            }
            
            // Split routing segments that exceed API limit
            const splitSegments = [];
            for (const seg of segments) {
                if (seg.mode === 'routing' && seg.waypointIndices.length > CONFIG.MAX_WAYPOINTS_PER_API_CALL) {
                    // Split into multiple segments
                    const indices = seg.waypointIndices;
                    for (let i = 0; i < indices.length - 1; i += CONFIG.MAX_WAYPOINTS_PER_API_CALL - 1) {
                        const end = Math.min(i + CONFIG.MAX_WAYPOINTS_PER_API_CALL, indices.length);
                        splitSegments.push({
                            mode: 'routing',
                            startIndex: indices[i],
                            endIndex: indices[end - 1],
                            waypointIndices: indices.slice(i, end)
                        });
                        // Overlap by one to maintain continuity
                        if (end < indices.length) i--;
                    }
                } else {
                    splitSegments.push(seg);
                }
            }
            
            return splitSegments;
        }

        /**
         * Calculate geometry for a single routing segment via API
         */
        async function calculateRoutingSegment(waypoints, segmentIndices, previousGeometryEnd) {
            const points = segmentIndices.map(i => waypoints[i]);
            
            // Determine start point - either previous geometry end or first waypoint
            let startPoint;
            if (previousGeometryEnd && segmentIndices[0] > 0) {
                startPoint = previousGeometryEnd;
            } else {
                startPoint = points[0];
            }
            
            const endPoint = points[points.length - 1];
            const middlePoints = points.slice(1, -1);
            
            try {
                const url = new URL('https://api.mapy.com/v1/routing/route');
                url.searchParams.set('apikey', CONFIG.API_KEY);
                url.searchParams.set('start', `${startPoint.lon},${startPoint.lat}`);
                url.searchParams.set('end', `${endPoint.lon},${endPoint.lat}`);
                url.searchParams.set('routeType', CONFIG.ROUTE_TYPE);
                url.searchParams.set('format', 'geojson');
                
                if (middlePoints.length > 0) {
                    middlePoints.forEach(wp => {
                        url.searchParams.append('waypoints', `${wp.lon},${wp.lat}`);
                    });
                }
                
                const response = await fetch(url.toString());
                if (!response.ok) {
                    throw new Error('Routing API error');
                }
                
                const data = await response.json();
                const coords = data.geometry.geometry.coordinates.map(c => ({
                    lon: c[0],
                    lat: c[1]
                }));
                
                return coords;
            } catch (error) {
                console.error('Routing error:', error);
                // Fallback to straight line
                return [startPoint, endPoint];
            }
        }

        /**
         * Calculate geometry for a manual segment (straight lines)
         */
        function calculateManualSegment(waypoints, segmentIndices, previousGeometryEnd) {
            const geometry = [];
            
            // If we have previousGeometryEnd, start from there and skip the first waypoint
            // (it's the shared boundary point with previous segment)
            if (previousGeometryEnd && segmentIndices.length > 0 && segmentIndices[0] > 0) {
                geometry.push({ lat: previousGeometryEnd.lat, lon: previousGeometryEnd.lon });
                // Skip first waypoint (shared boundary), start from second
                for (let i = 1; i < segmentIndices.length; i++) {
                    const wp = waypoints[segmentIndices[i]];
                    geometry.push({ lat: wp.lat, lon: wp.lon });
                }
            } else {
                // No previous geometry (first segment) - include all waypoints
                for (let i = 0; i < segmentIndices.length; i++) {
                    const wp = waypoints[segmentIndices[i]];
                    geometry.push({ lat: wp.lat, lon: wp.lon });
                }
            }
            
            return geometry;
        }

        // ======================
        // SMART SEGMENT RECALCULATION
        // ======================
        
        /**
         * Get the end point of previous segment's geometry (for continuity)
         */
        function getPreviousGeometryEnd(route, segmentIndex) {
            if (segmentIndex > 0 && route.segments[segmentIndex - 1]) {
                const prevGeom = route.segments[segmentIndex - 1].geometry;
                if (prevGeom && prevGeom.length > 0) {
                    return prevGeom[prevGeom.length - 1];
                }
            }
            return null;
        }
        
        /**
         * Calculate geometry for a single segment
         */
        async function calculateSegmentGeometry(route, segment, previousGeometryEnd) {
            if (segment.mode === 'routing') {
                return await calculateRoutingSegment(
                    route.waypoints,
                    segment.waypointIndices,
                    previousGeometryEnd
                );
            } else {
                return calculateManualSegment(
                    route.waypoints,
                    segment.waypointIndices,
                    previousGeometryEnd
                );
            }
        }
        
        /**
         * Recalculate geometry for a range of segments
         */
        async function recalculateSegmentRange(route, fromIndex, toIndex) {
            const hasRouting = route.segments.slice(fromIndex, toIndex + 1).some(s => s.mode === 'routing');
            if (hasRouting) showLoading();
            
            try {
                for (let i = fromIndex; i <= toIndex && i < route.segments.length; i++) {
                    const seg = route.segments[i];
                    const prevEnd = getPreviousGeometryEnd(route, i);
                    seg.geometry = await calculateSegmentGeometry(route, seg, prevEnd);
                }
            } finally {
                if (hasRouting) hideLoading();
            }
            
            // Fix manual-to-routing connections in the affected range and neighbors
            fixManualToRoutingConnections(route);
        }
        
        /**
         * Check if two segment definitions are equivalent (same waypoints)
         */
        function segmentsAreEquivalent(oldSeg, newSeg) {
            if (!oldSeg || !newSeg) return false;
            if (oldSeg.mode !== newSeg.mode) return false;
            if (oldSeg.waypointIndices.length !== newSeg.waypointIndices.length) return false;
            return oldSeg.waypointIndices.every((idx, i) => idx === newSeg.waypointIndices[i]);
        }
        
        /**
         * Main smart recalculation function
         * Handles all cases: move, insert, append, delete, mode change
         * 
         * @param {Object} route - The route to recalculate
         * @param {Object} options - Options for recalculation
         * @param {string} options.operation - 'move', 'insert', 'append', 'delete', 'modeChange', 'full'
         * @param {number} options.waypointIndex - Index of affected waypoint (for move, insert, delete)
         * @param {number} options.segmentIndex - Index of affected segment (for insert midpoint)
         */
        async function smartRecalculate(route, options = {}) {
            const { operation = 'full', waypointIndex, segmentIndex } = options;
            
            // For 'move' operation, structure doesn't change - just recalculate affected segments
            if (operation === 'move' && waypointIndex !== undefined && route.segments.length > 0) {
                // Find segments containing this waypoint
                const affectedIndices = [];
                for (let i = 0; i < route.segments.length; i++) {
                    if (route.segments[i].waypointIndices.includes(waypointIndex)) {
                        affectedIndices.push(i);
                    }
                }
                
                if (affectedIndices.length === 0) return;
                
                let fromIdx = Math.min(...affectedIndices);
                let toIdx = Math.max(...affectedIndices);
                
                // If waypoint is at boundary, also recalculate next segment
                const isAtBoundary = affectedIndices.length > 1 || 
                    route.segments[fromIdx].startIndex === waypointIndex ||
                    route.segments[toIdx].endIndex === waypointIndex;
                
                if (isAtBoundary && toIdx + 1 < route.segments.length) {
                    toIdx++;
                }
                
                await recalculateSegmentRange(route, fromIdx, toIdx);
                return;
            }
            
            // For operations that change structure, rebuild and compare
            const oldSegments = route.segments;
            const newSegmentDefs = analyzeSegments(route.waypoints);
            
            // Build new segments, preserving geometry where possible
            route.segments = [];
            let firstChangedIndex = -1;
            
            for (let i = 0; i < newSegmentDefs.length; i++) {
                const newDef = newSegmentDefs[i];
                const oldSeg = oldSegments[i];
                
                const newSeg = {
                    mode: newDef.mode,
                    startIndex: newDef.startIndex,
                    endIndex: newDef.endIndex,
                    waypointIndices: newDef.waypointIndices,
                    geometry: []
                };
                
                // Check if we can reuse old geometry
                if (segmentsAreEquivalent(oldSeg, newDef) && oldSeg.geometry) {
                    newSeg.geometry = oldSeg.geometry;
                } else {
                    // Mark this as first changed segment
                    if (firstChangedIndex === -1) {
                        firstChangedIndex = i;
                    }
                }
                
                route.segments.push(newSeg);
            }
            
            // If no segments changed and counts match, we're done
            if (firstChangedIndex === -1 && newSegmentDefs.length === oldSegments.length) {
                return;
            }
            
            // Recalculate from first changed segment to end
            // (because each segment depends on previous geometry end)
            const startIdx = firstChangedIndex === -1 ? 0 : firstChangedIndex;
            await recalculateSegmentRange(route, startIdx, route.segments.length - 1);
            
            // Fix all manual-to-routing connections
            fixManualToRoutingConnections(route);
        }
        
        /**
         * Fix connections between manual and routing segments
         * Manual segments should end at the start of following routing segments (no gaps)
         */
        function fixManualToRoutingConnections(route) {
            for (let i = 0; i < route.segments.length - 1; i++) {
                const currentSeg = route.segments[i];
                const nextSeg = route.segments[i + 1];
                
                // If current is manual and next is routing, fix the connection
                if (currentSeg.mode === 'manual' && nextSeg.mode === 'routing' &&
                    currentSeg.geometry.length > 0 && nextSeg.geometry.length > 0) {
                    const routingStart = nextSeg.geometry[0];
                    currentSeg.geometry[currentSeg.geometry.length - 1] = {
                        lat: routingStart.lat,
                        lon: routingStart.lon
                    };
                }
            }
        }
        
        /**
         * Legacy function for full recalculation (for import, etc.)
         */
        async function recalculateRouteGeometry(route) {
            await smartRecalculate(route, { operation: 'full' });
        }

        // ======================
        // HOVER MARKER FOR MIDPOINTS
        // ======================
        
        /**
         * Find the closest point on a polyline to a given latlng
         * Returns the point, geometry index, and which waypoint pair it's between
         */
        function findClosestPointOnGeometry(latlng, segment, route) {
            const geometry = segment.geometry;
            let closestDist = Infinity;
            let closestPoint = null;
            let closestGeomIndex = 0;
            
            for (let i = 0; i < geometry.length - 1; i++) {
                const p1 = geometry[i];
                const p2 = geometry[i + 1];
                
                // Project point onto line segment
                const projected = projectPointOnSegment(latlng, p1, p2);
                const dist = distanceSquared(latlng, projected);
                
                if (dist < closestDist) {
                    closestDist = dist;
                    closestPoint = projected;
                    closestGeomIndex = i;
                }
            }
            
            // Now determine which waypoint pair this geometry index falls between
            let insertIndex;
            let inheritedMode;
            
            if (segment.mode === 'manual') {
                // For manual segments:
                // - If startIndex > 0: geometry[0] = previousGeometryEnd, geometry[i] for i>=1 maps to waypointIndices[i]
                // - If startIndex === 0: geometry[i] maps directly to waypointIndices[i]
                const hasPreviousGeometry = segment.startIndex > 0;
                
                if (hasPreviousGeometry) {
                    // geometry[0] = previousGeometryEnd (not a waypoint)
                    // geometry[i] for i >= 1 corresponds to waypointIndices[i]
                    if (closestGeomIndex === 0) {
                        // Clicking between previousGeometryEnd and first actual manual waypoint
                        // Insert at position of first manual waypoint (waypointIndices[1])
                        insertIndex = segment.waypointIndices[1];
                    } else {
                        // Clicking between geometry[closestGeomIndex] and geometry[closestGeomIndex+1]
                        // which corresponds to waypointIndices[closestGeomIndex] and waypointIndices[closestGeomIndex+1]
                        insertIndex = segment.waypointIndices[closestGeomIndex] + 1;
                    }
                } else {
                    // First segment - geometry maps directly to waypoints
                    // geometry[i] = waypoints[waypointIndices[i]]
                    insertIndex = segment.waypointIndices[closestGeomIndex] + 1;
                }
                inheritedMode = 'manual';
            } else {
                // For routing segments, find which pair of waypoints this point is between
                // We need to find geometry indices that correspond to waypoints
                const waypointGeomIndices = findWaypointGeometryIndices(segment, route);
                
                // Find which segment of waypoints we're in
                let wpPairStart = 0;
                for (let i = 0; i < waypointGeomIndices.length - 1; i++) {
                    if (closestGeomIndex >= waypointGeomIndices[i] && closestGeomIndex < waypointGeomIndices[i + 1]) {
                        wpPairStart = i;
                        break;
                    }
                    wpPairStart = i;
                }
                
                // Insert after this waypoint in the segment
                insertIndex = segment.waypointIndices[wpPairStart] + 1;
                inheritedMode = 'routing';
            }
            
            return { 
                point: closestPoint, 
                geomIndex: closestGeomIndex, 
                distance: Math.sqrt(closestDist),
                insertIndex: insertIndex,
                mode: inheritedMode
            };
        }
        
        /**
         * Find geometry indices that correspond to waypoints in a routing segment
         */
        function findWaypointGeometryIndices(segment, route) {
            const indices = [0]; // First waypoint is at geometry index 0
            
            // For each intermediate waypoint, find closest geometry point
            for (let i = 1; i < segment.waypointIndices.length - 1; i++) {
                const wpIdx = segment.waypointIndices[i];
                const wp = route.waypoints[wpIdx];
                
                let closestDist = Infinity;
                let closestIdx = 0;
                
                for (let j = 0; j < segment.geometry.length; j++) {
                    const g = segment.geometry[j];
                    const dist = (wp.lat - g.lat) ** 2 + (wp.lon - g.lon) ** 2;
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestIdx = j;
                    }
                }
                indices.push(closestIdx);
            }
            
            indices.push(segment.geometry.length - 1); // Last waypoint is at last geometry index
            return indices;
        }
        
        /**
         * Project a point onto a line segment
         */
        function projectPointOnSegment(point, p1, p2) {
            const dx = p2.lon - p1.lon;
            const dy = p2.lat - p1.lat;
            
            if (dx === 0 && dy === 0) {
                return { lat: p1.lat, lon: p1.lon };
            }
            
            const t = Math.max(0, Math.min(1, 
                ((point.lng - p1.lon) * dx + (point.lat - p1.lat) * dy) / (dx * dx + dy * dy)
            ));
            
            return {
                lat: p1.lat + t * dy,
                lon: p1.lon + t * dx
            };
        }
        
        /**
         * Calculate squared distance between two points (for comparison, avoids sqrt)
         */
        function distanceSquared(p1, p2) {
            const dlat = p1.lat - p2.lat;
            const dlon = (p1.lng || p1.lon) - p2.lon;
            return dlat * dlat + dlon * dlon;
        }
        
        /**
         * Show hover marker at position
         */
        function showHoverMarker(lat, lon, data) {
            if (!hoverMarker) {
                hoverMarker = L.marker([lat, lon], {
                    icon: L.divIcon({
                        className: 'hover-midpoint-marker',
                        html: `<div style="width: 24px; height: 24px; background: rgba(76, 175, 80, 0.95); border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 8px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; cursor: crosshair; pointer-events: auto;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                        </div>`,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    }),
                    interactive: true,
                    zIndexOffset: 2000
                }).addTo(map);
                
                hoverMarker.on('click', async (e) => {
                    L.DomEvent.stopPropagation(e);
                    if (hoverMarkerData) {
                        const dataToInsert = { ...hoverMarkerData };
                        await insertMidpoint(dataToInsert);
                    }
                });
            } else {
                hoverMarker.setLatLng([lat, lon]);
                if (!map.hasLayer(hoverMarker)) {
                    hoverMarker.addTo(map);
                }
            }
            
            hoverMarkerData = data;
        }
        
        /**
         * Hide hover marker
         */
        function hideHoverMarker() {
            if (hoverMarker && map.hasLayer(hoverMarker)) {
                map.removeLayer(hoverMarker);
            }
            hoverMarkerData = null;
        }
        
        /**
         * Update hover marker position based on mouse location
         * Called from map mousemove handler
         */
        function updateHoverMarkerPosition(latlng) {
            // Only show when editing and have segments
            if (!isEditing || !activeRouteId) {
                hideHoverMarker();
                return;
            }
            
            const route = routes.find(r => r.id === activeRouteId);
            if (!route || !route.segments || route.segments.length === 0) {
                hideHoverMarker();
                return;
            }
            
            // Check if mouse is near any existing waypoint (within 20 pixels)
            const mousePoint = map.latLngToContainerPoint(latlng);
            for (let i = 0; i < route.waypoints.length; i++) {
                const wp = route.waypoints[i];
                const wpPixels = map.latLngToContainerPoint([wp.lat, wp.lon]);
                const distanceToWp = Math.sqrt(
                    Math.pow(mousePoint.x - wpPixels.x, 2) + 
                    Math.pow(mousePoint.y - wpPixels.y, 2)
                );
                
                // If near existing waypoint, hide insert marker
                if (distanceToWp < 20) {
                    hideHoverMarker();
                    return;
                }
            }
            
            // Find closest point on any segment
            let closestResult = null;
            let closestSegmentIndex = -1;
            let minPixelDistance = Infinity;
            
            for (let segIdx = 0; segIdx < route.segments.length; segIdx++) {
                const segment = route.segments[segIdx];
                if (!segment.geometry || segment.geometry.length < 2) continue;
                
                const result = findClosestPointOnGeometry(latlng, segment, route);
                if (result.point) {
                    // Calculate distance in pixels
                    const pointPixels = map.latLngToContainerPoint([result.point.lat, result.point.lon]);
                    const pixelDistance = Math.sqrt(
                        Math.pow(mousePoint.x - pointPixels.x, 2) + 
                        Math.pow(mousePoint.y - pointPixels.y, 2)
                    );
                    
                    if (pixelDistance < minPixelDistance) {
                        minPixelDistance = pixelDistance;
                        closestResult = result;
                        closestSegmentIndex = segIdx;
                    }
                }
            }
            
            // Show marker if close enough (within 20 pixels)
            if (closestResult && minPixelDistance < 20) {
                showHoverMarker(closestResult.point.lat, closestResult.point.lon, {
                    lat: closestResult.point.lat,
                    lon: closestResult.point.lon,
                    insertIndex: closestResult.insertIndex,
                    mode: closestResult.mode,
                    segmentIndex: closestSegmentIndex
                });
            } else {
                hideHoverMarker();
            }
        }
        
        /**
         * Insert a midpoint at the specified position
         * Optimized to only recalculate affected segments
         */
        async function insertMidpoint(data) {
            const route = routes.find(r => r.id === activeRouteId);
            if (!route) return;
            
            const { lat, lon, insertIndex, mode, segmentIndex } = data;
            
            // Validate insert index
            if (insertIndex < 1 || insertIndex > route.waypoints.length) {
                console.error('Invalid insert index:', insertIndex);
                return;
            }
            
            // Insert the new waypoint
            route.waypoints.splice(insertIndex, 0, {
                lat: lat,
                lon: lon,
                mode: mode
            });
            
            hideHoverMarker();
            
            // Optimized recalculation: only recalculate affected segments
            await smartRecalculate(route, { operation: 'insert', waypointIndex: insertIndex, segmentIndex });
            
            renderRoute(route, true);
            updateUI();
        }
        
        // ======================
        // ROUTE RENDERING
        // ======================
        function renderRoute(route, isActive = false) {
            // Remove existing layers
            if (routeLayers[route.id]) {
                if (routeLayers[route.id].lines) {
                    routeLayers[route.id].lines.forEach(l => map.removeLayer(l));
                }
                if (routeLayers[route.id].markers) {
                    routeLayers[route.id].markers.forEach(m => map.removeLayer(m));
                }
            }

            if (route.waypoints.length === 0) {
                routeLayers[route.id] = { lines: [], markers: [] };
                return;
            }

            const color = getColorHex(route.color);
            const lines = [];
            const markers = [];

            // Render segments
            if (route.segments && route.segments.length > 0) {
                for (const segment of route.segments) {
                    if (segment.geometry.length < 2) continue;
                    
                    const latLngs = segment.geometry.map(c => [c.lat, c.lon]);
                    
                    const lineOptions = {
                        color: color,
                        weight: isActive ? 7 : 5,
                        opacity: 0.95
                    };
                    
                    // Dashed line for manual segments (only in edit mode)
                    if (isActive && segment.mode === 'manual') {
                        lineOptions.dashArray = '10, 10';
                    }
                    
                    const line = L.polyline(latLngs, lineOptions).addTo(map);
                    
                    if (!isActive) {
                        line.bindTooltip(route.name || `Trasa ${route.id}`, {
                            permanent: false,
                            direction: 'top',
                            className: 'route-tooltip'
                        });
                        
                        line.on('mouseover', () => {
                            if (!isEditing) {
                                highlightRouteInMap(route.id, true);
                            }
                        });
                        
                        line.on('mouseout', () => {
                            if (!isEditing) {
                                highlightRouteInMap(route.id, false);
                            }
                        });
                        
                        line.on('click', () => {
                            if (!isEditing) {
                                activateRouteWithBestFit(route.id);
                            }
                        });
                    }
                    // No special handlers needed for active route lines
                    // The map mousemove handler takes care of hover marker
                    
                    lines.push(line);
                }
            }

            // Render waypoint markers (only when active)
            if (isActive) {
                route.waypoints.forEach((wp, index) => {
                    const isFirst = index === 0;
                    const isLast = index === route.waypoints.length - 1;
                    
                    let markerColor, markerSize;
                    if (isFirst) {
                        markerColor = '#4CAF50'; // Green for start
                        markerSize = 16;
                    } else if (isLast) {
                        markerColor = '#F44336'; // Red for end
                        markerSize = 16;
                    } else if (wp.mode === 'routing') {
                        markerColor = '#FFC107'; // Yellow for routing
                        markerSize = 14;
                    } else {
                        markerColor = '#90CAF9'; // Light blue for manual
                        markerSize = 14;
                    }
                    
                    const marker = L.marker([wp.lat, wp.lon], {
                        draggable: true,
                        icon: L.divIcon({
                            className: 'vertex-marker',
                            html: `<div style="width: ${markerSize}px; height: ${markerSize}px; background: ${markerColor}; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                            iconSize: [markerSize, markerSize]
                        })
                    }).addTo(map);
                    
                    marker.on('dragend', async () => {
                        const latlng = marker.getLatLng();
                        route.waypoints[index].lat = latlng.lat;
                        route.waypoints[index].lon = latlng.lng;
                        await smartRecalculate(route, { operation: 'move', waypointIndex: index });
                        renderRoute(route, true);
                    });
                    
                    marker.on('contextmenu', (e) => {
                        L.DomEvent.stopPropagation(e);
                        const pixel = map.latLngToContainerPoint(e.latlng);
                        showContextMenu(pixel.x, pixel.y, { type: 'waypoint', index: index, mode: wp.mode });
                    });
                    
                    markers.push(marker);
                });
            }

            routeLayers[route.id] = { lines, markers };
        }

        function renderAllRoutes() {
            routes.forEach(route => {
                const isActive = route.id === activeRouteId && isEditing;
                renderRoute(route, isActive);
            });
        }

        // ======================
        // CONTEXT MENU
        // ======================
        const contextMenu = document.getElementById('context-menu');
        
        function showContextMenu(x, y, data) {
            contextMenuData = data;
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenu.style.display = 'block';
            
            // Show/hide mode change options based on current mode
            const routingOption = document.getElementById('context-menu-mode-routing');
            const manualOption = document.getElementById('context-menu-mode-manual');
            
            if (data.type === 'waypoint' && data.index > 0) {
                // Not start point, can change mode
                routingOption.style.display = data.mode === 'routing' ? 'none' : 'flex';
                manualOption.style.display = data.mode === 'manual' ? 'none' : 'flex';
            } else {
                // Start point - hide mode options
                routingOption.style.display = 'none';
                manualOption.style.display = 'none';
            }
        }
        
        function hideContextMenu() {
            contextMenu.style.display = 'none';
            contextMenuData = null;
        }
        
        document.addEventListener('click', () => {
            hideContextMenu();
        });
        
        // Context menu: Delete point
        document.getElementById('context-menu-delete').addEventListener('click', async (e) => {
            e.stopPropagation();
            if (contextMenuData && contextMenuData.type === 'waypoint') {
                await deleteWaypoint(contextMenuData.index);
            }
            hideContextMenu();
        });
        
        // Context menu: Split route
        document.getElementById('context-menu-split').addEventListener('click', async (e) => {
            e.stopPropagation();
            if (contextMenuData && contextMenuData.type === 'waypoint') {
                await splitRoute(contextMenuData.index);
            }
            hideContextMenu();
        });
        
        // Context menu: Change to routing
        document.getElementById('context-menu-mode-routing').addEventListener('click', async (e) => {
            e.stopPropagation();
            if (contextMenuData && contextMenuData.type === 'waypoint') {
                await changeWaypointMode(contextMenuData.index, 'routing');
            }
            hideContextMenu();
        });
        
        // Context menu: Change to manual
        document.getElementById('context-menu-mode-manual').addEventListener('click', async (e) => {
            e.stopPropagation();
            if (contextMenuData && contextMenuData.type === 'waypoint') {
                await changeWaypointMode(contextMenuData.index, 'manual');
            }
            hideContextMenu();
        });
        
        async function deleteWaypoint(index) {
            const route = routes.find(r => r.id === activeRouteId);
            if (!route) return;
            
            if (route.waypoints.length <= 2) {
                alert('Trasa mus√≠ m√≠t minim√°lnƒõ 2 body.');
                return;
            }
            
            route.waypoints.splice(index, 1);
            await recalculateRouteGeometry(route);
            renderRoute(route, true);
            updateUI();
        }
        
        async function splitRoute(index) {
            const route = routes.find(r => r.id === activeRouteId);
            if (!route) return;
            
            if (index === 0 || index === route.waypoints.length - 1) {
                alert('Nelze rozdƒõlit trasu na prvn√≠m nebo posledn√≠m bodƒõ.');
                return;
            }
            
            // Create second route with waypoints from split point
            const wp2 = route.waypoints.slice(index);
            // Make the split point the new start
            wp2[0] = { ...wp2[0], mode: 'start' };
            
            const newRoute = {
                id: nextRouteId++,
                name: route.name + ' (2)',
                color: route.color,
                waypoints: wp2,
                segments: []
            };
            
            // Truncate original route
            route.waypoints = route.waypoints.slice(0, index + 1);
            
            // Recalculate both routes
            await recalculateRouteGeometry(route);
            await recalculateRouteGeometry(newRoute);
            
            routes.push(newRoute);
            
            // Exit editing mode
            deactivateRoute();
            renderAllRoutes();
            updateUI();
        }
        
        async function changeWaypointMode(index, newMode) {
            const route = routes.find(r => r.id === activeRouteId);
            if (!route || index === 0) return;
            
            route.waypoints[index].mode = newMode;
            await recalculateRouteGeometry(route);
            renderRoute(route, true);
            updateUI();
        }

        // ======================
        // ROUTE MANAGEMENT
        // ======================
        function createRoute(name = 'Nov√° trasa', color = 'red') {
            const route = {
                id: nextRouteId++,
                name,
                color,
                waypoints: [],
                segments: []
            };
            routes.push(route);
            return route;
        }

        function activateRouteWithBestFit(routeId) {
            activateRoute(routeId);
            
            const route = routes.find(r => r.id === routeId);
            if (route && route.waypoints.length > 0) {
                const latLngs = route.waypoints.map(wp => [wp.lat, wp.lon]);
                const bounds = L.latLngBounds(latLngs);
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }

        function activateRoute(routeId) {
            if (isEditing) return;
            
            const previousActiveId = activeRouteId;
            activeRouteId = routeId;
            isEditing = true;
            
            const route = routes.find(r => r.id === routeId);
            if (route) {
                // Create backup
                routeBackup = JSON.parse(JSON.stringify(route));
            }
            
            // Re-render affected routes
            if (previousActiveId && previousActiveId !== routeId) {
                const prevRoute = routes.find(r => r.id === previousActiveId);
                if (prevRoute) {
                    renderRoute(prevRoute, false);
                }
            }
            
            if (route) {
                renderRoute(route, true);
            }
            
            updateUI();
        }

        function deactivateRoute() {
            const previousActiveId = activeRouteId;
            activeRouteId = null;
            isEditing = false;
            routeBackup = null;
            
            // Hide hover marker
            hideHoverMarker();
            
            if (previousActiveId) {
                const prevRoute = routes.find(r => r.id === previousActiveId);
                if (prevRoute) {
                    renderRoute(prevRoute, false);
                }
            }
            
            updateUI();
        }

        function cancelRouteEditing() {
            const route = routes.find(r => r.id === activeRouteId);
            if (!route) {
                deactivateRoute();
                return;
            }
            
            // Check if this is a new route (backup had no waypoints)
            const isNewRoute = !routeBackup || routeBackup.waypoints.length < 2;
            
            // Check if there are any changes to cancel
            const hasChanges = route.waypoints.length > 0 || 
                route.name !== (routeBackup?.name || 'Nov√° trasa') ||
                route.color !== (routeBackup?.color || 'red');
            
            if (hasChanges && !confirm('Opravdu zru≈°it zmƒõny proveden√© v trase?')) {
                return;
            }
            
            if (isNewRoute) {
                // New route - delete it completely
                deleteRoute(activeRouteId);
            } else if (routeBackup && activeRouteId) {
                // Existing route - restore from backup
                route.name = routeBackup.name;
                route.color = routeBackup.color;
                route.waypoints = routeBackup.waypoints;
                route.segments = routeBackup.segments;
                renderRoute(route, false);
            }
            
            deactivateRoute();
        }

        function deleteRoute(routeId) {
            const index = routes.findIndex(r => r.id === routeId);
            if (index !== -1) {
                routes.splice(index, 1);
                if (routeLayers[routeId]) {
                    if (routeLayers[routeId].lines) {
                        routeLayers[routeId].lines.forEach(l => map.removeLayer(l));
                    }
                    if (routeLayers[routeId].markers) {
                        routeLayers[routeId].markers.forEach(m => map.removeLayer(m));
                    }
                    delete routeLayers[routeId];
                }
                if (activeRouteId === routeId) {
                    activeRouteId = null;
                    isEditing = false;
                }
                updateUI();
            }
        }

        // ======================
        // MAP INTERACTIONS
        // ======================
        map.on('contextmenu', (e) => {
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
        });
        
        map.on('mousemove', (e) => {
            // Handle hover marker for midpoint insertion
            updateHoverMarkerPosition(e.latlng);
        });
        
        map.on('click', async (e) => {
            if (!isEditing || !activeRouteId) return;
            
            const route = routes.find(r => r.id === activeRouteId);
            if (!route) return;
            
            const clickedLat = e.latlng.lat;
            const clickedLon = e.latlng.lng;
            
            if (route.waypoints.length === 0) {
                // Add start point (no modifier needed)
                route.waypoints.push({
                    lat: clickedLat,
                    lon: clickedLon,
                    mode: 'start'
                });
                renderRoute(route, true);
                updateUI();
            } else if (ctrlPressed) {
                // Add routing waypoint
                route.waypoints.push({
                    lat: clickedLat,
                    lon: clickedLon,
                    mode: 'routing'
                });
                await smartRecalculate(route, { operation: 'append', waypointIndex: route.waypoints.length - 1 });
                renderRoute(route, true);
                updateUI();
            } else if (altPressed) {
                // Add manual waypoint
                route.waypoints.push({
                    lat: clickedLat,
                    lon: clickedLon,
                    mode: 'manual'
                });
                await smartRecalculate(route, { operation: 'append', waypointIndex: route.waypoints.length - 1 });
                renderRoute(route, true);
                updateUI();
            }
        });

        // ======================
        // GPX IMPORT/EXPORT
        // ======================
        function escapeXml(text) {
            return text.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;')
                       .replace(/'/g, '&apos;');
        }

        function exportGPX() {
            // Filter routes with at least 2 waypoints
            const validRoutes = routes.filter(r => r.waypoints && r.waypoints.length >= 2);
            
            if (validRoutes.length === 0) {
                alert('≈Ω√°dn√© trasy k exportu');
                return;
            }

            let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n';
            gpx += '<gpx version="1.1" creator="MapyEditorBeta" xmlns="http://www.topografix.com/GPX/1/1" xmlns:gpxx="http://www.garmin.com/xmlschemas/GpxExtensions/v3">\n';

            validRoutes.forEach(route => {
                gpx += '  <trk>\n';
                gpx += `    <name>${escapeXml(route.name || 'Trasa ' + route.id)}</name>\n`;
                gpx += '    <extensions>\n';
                gpx += `      <gpxx:DisplayColor>${route.color}</gpxx:DisplayColor>\n`;
                gpx += '    </extensions>\n';
                
                // Export each segment as a trkseg
                if (route.segments && route.segments.length > 0) {
                    for (let segIdx = 0; segIdx < route.segments.length; segIdx++) {
                        const segment = route.segments[segIdx];
                        gpx += '    <trkseg>\n';
                        gpx += '      <extensions>\n';
                        gpx += `        <gpxx:SegmentMode>${segment.mode}</gpxx:SegmentMode>\n`;
                        
                        if (segment.mode === 'routing') {
                            // Save start, end, and waypoints for routing segments
                            const startWp = route.waypoints[segment.startIndex];
                            const endWp = route.waypoints[segment.endIndex];
                            gpx += `        <gpxx:StartPoint lat="${startWp.lat}" lon="${startWp.lon}"/>\n`;
                            gpx += `        <gpxx:EndPoint lat="${endWp.lat}" lon="${endWp.lon}"/>\n`;
                            
                            // Middle waypoints
                            if (segment.waypointIndices.length > 2) {
                                gpx += '        <gpxx:Waypoints>\n';
                                for (let i = 1; i < segment.waypointIndices.length - 1; i++) {
                                    const wp = route.waypoints[segment.waypointIndices[i]];
                                    gpx += `          <gpxx:Waypoint lat="${wp.lat}" lon="${wp.lon}"/>\n`;
                                }
                                gpx += '        </gpxx:Waypoints>\n';
                            }
                        }
                        // Note: StartsFromPreviousGeometry is auto-detected on import based on previous segment type
                        
                        gpx += '      </extensions>\n';
                        
                        // Geometry points
                        segment.geometry.forEach(coord => {
                            gpx += `      <trkpt lat="${coord.lat}" lon="${coord.lon}"></trkpt>\n`;
                        });
                        
                        gpx += '    </trkseg>\n';
                    }
                } else if (route.waypoints.length > 0) {
                    // Fallback: single segment with all waypoints
                    gpx += '    <trkseg>\n';
                    route.waypoints.forEach(wp => {
                        gpx += `      <trkpt lat="${wp.lat}" lon="${wp.lon}"></trkpt>\n`;
                    });
                    gpx += '    </trkseg>\n';
                }
                
                gpx += '  </trk>\n';
            });

            gpx += '</gpx>';

            const blob = new Blob([gpx], { type: 'application/gpx+xml' });
            
            if ('showSaveFilePicker' in window) {
                saveFileModern(blob);
            } else {
                saveFileFallback(blob);
            }
        }

        async function saveFileModern(blob) {
            try {
                const now = new Date();
                const year = now.getFullYear().toString().slice(-2);
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const filename = `routes_${year}${month}${day}_${hours}${minutes}.gpx`;
                
                const options = {
                    types: [{
                        description: 'GPX soubory',
                        accept: { 'application/gpx+xml': ['.gpx'] }
                    }],
                    suggestedName: filename
                };
                
                const handle = await window.showSaveFilePicker(options);
                const writable = await handle.createWritable();
                await writable.write(blob);
                await writable.close();
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Save error:', err);
                    saveFileFallback(blob);
                }
            }
        }

        function saveFileFallback(blob) {
            const now = new Date();
            const year = now.getFullYear().toString().slice(-2);
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const filename = `routes_${year}${month}${day}_${hours}${minutes}.gpx`;
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        async function importGPX(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                    const tracks = xmlDoc.getElementsByTagName('trk');

                    for (const trk of Array.from(tracks)) {
                        const nameEl = trk.getElementsByTagName('name')[0];
                        const name = nameEl ? nameEl.textContent : file.name.replace('.gpx', '');
                        
                        let color = 'red';
                        let oldRouteMode = null;
                        let oldWaypoints = [];
                        
                        // Check for extensions at trk level
                        const trkExtensions = trk.getElementsByTagName('extensions')[0];
                        if (trkExtensions) {
                            const displayColorEl = trkExtensions.getElementsByTagName('gpxx:DisplayColor')[0] || 
                                                   trkExtensions.getElementsByTagName('DisplayColor')[0];
                            if (displayColorEl) {
                                const colorValue = displayColorEl.textContent.toLowerCase();
                                if (['red', 'blue', 'green'].includes(colorValue)) {
                                    color = colorValue;
                                }
                            }
                            
                            // Check for old format RouteMode
                            const routeModeEl = trkExtensions.getElementsByTagName('gpxx:RouteMode')[0] || 
                                               trkExtensions.getElementsByTagName('RouteMode')[0];
                            if (routeModeEl) {
                                oldRouteMode = routeModeEl.textContent.toLowerCase();
                            }
                            
                            // Check for old format Waypoints
                            const waypointsEl = trkExtensions.getElementsByTagName('gpxx:Waypoints')[0] || 
                                               trkExtensions.getElementsByTagName('Waypoints')[0];
                            if (waypointsEl) {
                                const wpEls = waypointsEl.getElementsByTagName('gpxx:Waypoint');
                                const wpEls2 = waypointsEl.getElementsByTagName('Waypoint');
                                const wpArray = wpEls.length > 0 ? wpEls : wpEls2;
                                oldWaypoints = Array.from(wpArray).map(wpEl => ({
                                    lat: parseFloat(wpEl.getAttribute('lat')),
                                    lon: parseFloat(wpEl.getAttribute('lon'))
                                }));
                            }
                        }
                        
                        const trksegs = trk.getElementsByTagName('trkseg');
                        const waypoints = [];
                        
                        // Check if new format (trkseg has extensions with SegmentMode)
                        let isNewFormat = false;
                        if (trksegs.length > 0) {
                            const firstTrkseg = trksegs[0];
                            const segExt = firstTrkseg.getElementsByTagName('extensions')[0];
                            if (segExt) {
                                const segModeEl = segExt.getElementsByTagName('gpxx:SegmentMode')[0] || 
                                                 segExt.getElementsByTagName('SegmentMode')[0];
                                if (segModeEl) {
                                    isNewFormat = true;
                                }
                            }
                        }
                        
                        if (isNewFormat) {
                            // New format: read segments with geometry from trkpt (no API calls needed!)
                            // 
                            // IMPORTANT: At segment boundaries, waypoints are SHARED between segments.
                            // The boundary waypoint's MODE is determined by the PREVIOUS segment.
                            // Example: routing‚Üímanual transition: boundary wp has mode 'routing'
                            //          manual‚Üírouting transition: boundary wp has mode 'manual'
                            
                            const importedSegments = [];
                            
                            for (let segIdx = 0; segIdx < trksegs.length; segIdx++) {
                                const trkseg = trksegs[segIdx];
                                const segExt = trkseg.getElementsByTagName('extensions')[0];
                                
                                let segMode = 'manual';
                                let startPoint = null;
                                let endPoint = null;
                                let segWaypoints = [];
                                
                                if (segExt) {
                                    const segModeEl = segExt.getElementsByTagName('gpxx:SegmentMode')[0] || 
                                                     segExt.getElementsByTagName('SegmentMode')[0];
                                    if (segModeEl) {
                                        segMode = segModeEl.textContent.toLowerCase();
                                    }
                                    
                                    const startEl = segExt.getElementsByTagName('gpxx:StartPoint')[0] || 
                                                   segExt.getElementsByTagName('StartPoint')[0];
                                    if (startEl) {
                                        startPoint = {
                                            lat: parseFloat(startEl.getAttribute('lat')),
                                            lon: parseFloat(startEl.getAttribute('lon'))
                                        };
                                    }
                                    
                                    const endEl = segExt.getElementsByTagName('gpxx:EndPoint')[0] || 
                                                 segExt.getElementsByTagName('EndPoint')[0];
                                    if (endEl) {
                                        endPoint = {
                                            lat: parseFloat(endEl.getAttribute('lat')),
                                            lon: parseFloat(endEl.getAttribute('lon'))
                                        };
                                    }
                                    
                                    const wpContainer = segExt.getElementsByTagName('gpxx:Waypoints')[0] || 
                                                       segExt.getElementsByTagName('Waypoints')[0];
                                    if (wpContainer) {
                                        const wpEls = wpContainer.getElementsByTagName('gpxx:Waypoint');
                                        const wpEls2 = wpContainer.getElementsByTagName('Waypoint');
                                        const wpArray = wpEls.length > 0 ? wpEls : wpEls2;
                                        segWaypoints = Array.from(wpArray).map(el => ({
                                            lat: parseFloat(el.getAttribute('lat')),
                                            lon: parseFloat(el.getAttribute('lon'))
                                        }));
                                    }
                                }
                                
                                // Read geometry from trkpt
                                const trkpts = trkseg.getElementsByTagName('trkpt');
                                const geometry = Array.from(trkpts).map(pt => ({
                                    lat: parseFloat(pt.getAttribute('lat')),
                                    lon: parseFloat(pt.getAttribute('lon'))
                                }));
                                
                                // Determine the previous segment info
                                const prevSeg = importedSegments.length > 0 ? importedSegments[importedSegments.length - 1] : null;
                                const boundaryWpIndex = prevSeg ? prevSeg.endIndex : -1;
                                
                                // Build waypoints for this segment
                                // Key insight: boundary waypoint is SHARED and already exists from previous segment
                                
                                if (segMode === 'routing') {
                                    // Routing segment: waypoints come from metadata (StartPoint, Waypoints, EndPoint)
                                    
                                    if (segIdx === 0) {
                                        // First segment: add startPoint
                                        if (startPoint) {
                                            waypoints.push({ ...startPoint, mode: 'start' });
                                        }
                                    }
                                    // For subsequent segments: startPoint = boundary waypoint, already exists
                                    // Don't add it again!
                                    
                                    // Add middle waypoints
                                    segWaypoints.forEach(wp => {
                                        waypoints.push({ ...wp, mode: 'routing' });
                                    });
                                    
                                    // Add endPoint
                                    if (endPoint) {
                                        waypoints.push({ ...endPoint, mode: 'routing' });
                                    }
                                } else {
                                    // Manual segment: waypoints come from trkpt (geometry points)
                                    // But geometry may start with previousGeometryEnd which is NOT a waypoint
                                    
                                    // Check if this manual segment starts from previous geometry end
                                    const startsFromPrevGeom = prevSeg && prevSeg.mode === 'routing';
                                    
                                    Array.from(trkpts).forEach((pt, ptIdx) => {
                                        // Skip first trkpt if it's previousGeometryEnd (not a waypoint)
                                        if (ptIdx === 0 && startsFromPrevGeom) {
                                            return;
                                        }
                                        
                                        const lat = parseFloat(pt.getAttribute('lat'));
                                        const lon = parseFloat(pt.getAttribute('lon'));
                                        
                                        // For subsequent segments, first actual waypoint is the boundary
                                        // Skip if it matches the boundary waypoint (already exists)
                                        if (boundaryWpIndex >= 0) {
                                            const boundaryWp = waypoints[boundaryWpIndex];
                                            if (boundaryWp && 
                                                Math.abs(boundaryWp.lat - lat) < 0.000001 && 
                                                Math.abs(boundaryWp.lon - lon) < 0.000001) {
                                                return; // Skip - this is the shared boundary waypoint
                                            }
                                        }
                                        
                                        if (waypoints.length === 0) {
                                            waypoints.push({ lat, lon, mode: 'start' });
                                        } else {
                                            waypoints.push({ lat, lon, mode: 'manual' });
                                        }
                                    });
                                }
                                
                                // Build waypointIndices for this segment
                                // Segments SHARE boundary waypoints!
                                const startIndex = (segIdx === 0) ? 0 : boundaryWpIndex;
                                const endIndex = waypoints.length - 1;
                                
                                const waypointIndices = [];
                                for (let wi = startIndex; wi <= endIndex; wi++) {
                                    waypointIndices.push(wi);
                                }
                                
                                importedSegments.push({
                                    mode: segMode,
                                    startIndex: startIndex,
                                    endIndex: endIndex,
                                    waypointIndices: waypointIndices,
                                    geometry: geometry
                                });
                            }
                            
                            // Create route with pre-loaded segments (no recalculation needed!)
                            if (waypoints.length > 0) {
                                const route = {
                                    id: nextRouteId++,
                                    name,
                                    color,
                                    waypoints,
                                    segments: importedSegments
                                };
                                // Fix connections without API calls
                                fixManualToRoutingConnections(route);
                                routes.push(route);
                            }
                            continue; // Skip the recalculate section below
                        } else if (oldRouteMode) {
                            // Old format compatibility - geometry is already in trkpt, no API calls needed!
                            const allTrkpts = [];
                            for (const trkseg of Array.from(trksegs)) {
                                const trkpts = trkseg.getElementsByTagName('trkpt');
                                allTrkpts.push(...Array.from(trkpts));
                            }
                            
                            // Read geometry from trkpt
                            const geometry = allTrkpts.map(pt => ({
                                lat: parseFloat(pt.getAttribute('lat')),
                                lon: parseFloat(pt.getAttribute('lon'))
                            }));
                            
                            if (oldRouteMode === 'manual') {
                                // All trkpt are manual waypoints (waypoints = geometry)
                                allTrkpts.forEach((pt, idx) => {
                                    waypoints.push({
                                        lat: parseFloat(pt.getAttribute('lat')),
                                        lon: parseFloat(pt.getAttribute('lon')),
                                        mode: idx === 0 ? 'start' : 'manual'
                                    });
                                });
                            } else if (oldRouteMode === 'routing') {
                                // First trkpt is start, last is end, waypoints from extensions
                                if (allTrkpts.length > 0) {
                                    waypoints.push({
                                        lat: parseFloat(allTrkpts[0].getAttribute('lat')),
                                        lon: parseFloat(allTrkpts[0].getAttribute('lon')),
                                        mode: 'start'
                                    });
                                    
                                    oldWaypoints.forEach(wp => {
                                        waypoints.push({ ...wp, mode: 'routing' });
                                    });
                                    
                                    if (allTrkpts.length > 1) {
                                        const lastPt = allTrkpts[allTrkpts.length - 1];
                                        waypoints.push({
                                            lat: parseFloat(lastPt.getAttribute('lat')),
                                            lon: parseFloat(lastPt.getAttribute('lon')),
                                            mode: 'routing'
                                        });
                                    }
                                }
                            }
                            
                            // Create route with pre-loaded geometry (no API calls!)
                            if (waypoints.length > 0) {
                                const waypointIndices = waypoints.map((_, i) => i);
                                const route = {
                                    id: nextRouteId++,
                                    name,
                                    color,
                                    waypoints,
                                    segments: [{
                                        mode: oldRouteMode,
                                        startIndex: 0,
                                        endIndex: waypoints.length - 1,
                                        waypointIndices: waypointIndices,
                                        geometry: geometry
                                    }]
                                };
                                routes.push(route);
                            }
                        } else {
                            // No format info - treat as manual, geometry = waypoints
                            const geometry = [];
                            for (const trkseg of Array.from(trksegs)) {
                                const trkpts = trkseg.getElementsByTagName('trkpt');
                                Array.from(trkpts).forEach((pt, idx) => {
                                    const lat = parseFloat(pt.getAttribute('lat'));
                                    const lon = parseFloat(pt.getAttribute('lon'));
                                    
                                    geometry.push({ lat, lon });
                                    
                                    if (waypoints.length === 0) {
                                        waypoints.push({ lat, lon, mode: 'start' });
                                    } else {
                                        waypoints.push({ lat, lon, mode: 'manual' });
                                    }
                                });
                            }
                            
                            // Create route with pre-loaded geometry (no API calls!)
                            if (waypoints.length > 0) {
                                const waypointIndices = waypoints.map((_, i) => i);
                                const route = {
                                    id: nextRouteId++,
                                    name,
                                    color,
                                    waypoints,
                                    segments: [{
                                        mode: 'manual',
                                        startIndex: 0,
                                        endIndex: waypoints.length - 1,
                                        waypointIndices: waypointIndices,
                                        geometry: geometry
                                    }]
                                };
                                routes.push(route);
                            }
                        }
                    }
                    
                    resolve();
                };
                reader.readAsText(file);
            });
        }

        async function importMultipleGPX(files) {
            const dropzoneContent = document.querySelector('.dropzone-content');
            const dropzoneLoading = document.getElementById('dropzone-loading');
            
            dropzoneContent.style.display = 'none';
            dropzoneLoading.style.display = 'flex';
            
            for (const file of Array.from(files)) {
                if (file.name.toLowerCase().endsWith('.gpx')) {
                    await importGPX(file);
                }
            }
            
            renderAllRoutes();
            updateUI();
            fitBoundsToRoutes();
            
            dropzoneLoading.style.display = 'none';
            dropzoneContent.style.display = 'block';
            
            setTimeout(() => {
                document.getElementById('import-panel').style.display = 'none';
            }, 500);
        }

        function fitBoundsToRoutes() {
            if (routes.length === 0) return;
            
            const allCoords = [];
            routes.forEach(route => {
                route.waypoints.forEach(wp => {
                    allCoords.push([wp.lat, wp.lon]);
                });
            });
            
            if (allCoords.length > 0) {
                const bounds = L.latLngBounds(allCoords);
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }

        // ======================
        // BUTTON HANDLERS
        // ======================
        document.getElementById('btn-create-route').addEventListener('click', () => {
            if (isEditing) return;
            const route = createRoute('Nov√° trasa', 'red');
            activateRoute(route.id);
        });

        document.getElementById('btn-save-route').addEventListener('click', () => {
            const route = routes.find(r => r.id === activeRouteId);
            if (route && route.waypoints.length < 2) {
                alert('Trasa mus√≠ m√≠t minim√°lnƒõ 2 body.');
                return;
            }
            deactivateRoute();
        });

        document.getElementById('btn-cancel-route').addEventListener('click', () => {
            cancelRouteEditing();
        });

        // Route menu handlers
        const routeMenuBtn = document.getElementById('route-menu-btn');
        const routeMenu = document.getElementById('route-menu');
        
        routeMenuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            routeMenu.classList.toggle('visible');
        });

        document.getElementById('menu-delete-route').addEventListener('click', (e) => {
            e.stopPropagation();
            routeMenu.classList.remove('visible');
            
            if (!activeRouteId) return;
            
            const route = routes.find(r => r.id === activeRouteId);
            const routeName = route ? route.name : 'tuto trasu';
            
            if (confirm(`Opravdu chcete smazat trasu "${routeName}"?`)) {
                deleteRoute(activeRouteId);
                activeRouteId = null;
                isEditing = false;
                routeBackup = null;
                hideHoverMarker();
                updateUI();
            }
        });

        // Close route menu when clicking elsewhere
        document.addEventListener('click', () => {
            routeMenu.classList.remove('visible');
        });

        // Import/Export handlers
        const dropzone = document.getElementById('dropzone');
        const gpxInput = document.getElementById('gpx-input');
        const importPanel = document.getElementById('import-panel');

        document.getElementById('btn-import-gpx').addEventListener('click', () => {
            if (!isEditing) {
                importPanel.style.display = 'block';
                dropzone.classList.add('visible');
            }
        });

        document.getElementById('btn-close-import').addEventListener('click', () => {
            importPanel.style.display = 'none';
            dropzone.classList.remove('visible');
        });

        dropzone.addEventListener('click', () => {
            if (!isEditing) {
                gpxInput.click();
            }
        });

        gpxInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importMultipleGPX(e.target.files);
                e.target.value = '';
            }
        });

        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!isEditing) {
                dropzone.classList.add('dragover');
            }
        });

        dropzone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
        });

        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
            
            if (!isEditing) {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    importMultipleGPX(files);
                }
            }
        });

        document.getElementById('btn-export-gpx').addEventListener('click', () => {
            exportGPX();
        });

        // ======================
        // ATTRIBUTE HANDLERS
        // ======================
        routeNameInput.addEventListener('input', () => {
            const route = routes.find(r => r.id === activeRouteId);
            if (route) {
                route.name = routeNameInput.value;
                updateUI();
            }
        });

        routeColorSelect.addEventListener('change', () => {
            const route = routes.find(r => r.id === activeRouteId);
            if (route) {
                route.color = routeColorSelect.value;
                renderRoute(route, true);
            }
        });

        // Route search
        document.getElementById('route-search-input').addEventListener('input', (e) => {
            routeSearchQuery = e.target.value;
            updateRoutesList();
        });

        // ======================
        // KEY TRACKING
        // ======================
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Control' || e.ctrlKey) {
                ctrlPressed = true;
                updateUI();
            }
            if (e.key === 'Alt' || e.altKey) {
                altPressed = true;
                e.preventDefault(); // Prevent menu from appearing
                updateUI();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Control' || !e.ctrlKey) {
                ctrlPressed = false;
                updateUI();
            }
            if (e.key === 'Alt' || !e.altKey) {
                altPressed = false;
                updateUI();
            }
        });

        window.addEventListener('blur', () => {
            ctrlPressed = false;
            altPressed = false;
            updateUI();
        });

        // Warn before leaving
        window.addEventListener('beforeunload', (e) => {
            if (routes.length > 0) {
                const message = 'Skuteƒçnƒõ chcete MapyEditor opustit? M√°te v≈°e ulo≈æen√© do souboru na disku?';
                e.preventDefault();
                e.returnValue = message;
                return message;
            }
        });

        // ======================
        // INITIALIZATION
        // ======================
        updateUI();
    </script>
</body>
</html>

